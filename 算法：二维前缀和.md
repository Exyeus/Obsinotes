**二维前缀和**（2D Prefix Sum）是一种扩展了**一维前缀和**的技术，用于快速计算二维数组中任意矩形区域的元素和。它通过预先计算一个二维数组的**前缀和**矩阵，从而可以在常数时间内快速求出任意子矩阵的和。

### 1. **一维前缀和的复习**

一维前缀和的定义是：对于数组 `arr[0], arr[1], ..., arr[n-1]`，前缀和数组 `prefix[0], prefix[1], ..., prefix[n]` 满足：

prefix[i]=arr[0]+arr[1]+...+arr[i−1]prefix[i] = arr[0] + arr[1] + ... + arr[i-1]

这样，给定一个区间 `[l, r]`，其和可以通过：

sum(l,r)=prefix[r+1]−prefix[l]sum(l, r) = prefix[r+1] - prefix[l]

来快速计算。

### 2. **二维前缀和的定义**

对于一个二维数组 `matrix`，假设其大小为 `m x n`（即有 `m` 行和 `n` 列），我们定义一个二维前缀和数组 `prefix`，其中 `prefix[i][j]` 表示从 `(0, 0)` 到 `(i-1, j-1)` 的矩形区域的元素和。即：
$$
prefix[i][j]=matrix[0][0]+matrix[0][1]+...+matrix[i−1][j−1]prefix[i][j] = \text{matrix}[0][0] + \text{matrix}[0][1] + ... + \text{matrix}[i-1][j-1]
$$
### 3. **二维前缀和的计算**

我们可以通过递推的方式来计算 `prefix` 数组的每个元素。假设 `matrix` 的大小是 `m x n`，则二维前缀和数组 `prefix` 的每个元素的计算方式为：
$$
prefix[i][j]=matrix[i−1][j−1]+prefix[i−1][j]+prefix[i][j−1]−prefix[i−1][j−1]prefix[i][j] = matrix[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]
$$
这里的递推公式是：

- `matrix[i-1][j-1]` 是当前元素。
- `prefix[i-1][j]` 是上方区域的和。
- `prefix[i][j-1]` 是左方区域的和。
- `prefix[i-1][j-1]` 是重复计算的区域，所以需要减去它。

### 4. **二维前缀和的应用**

通过计算二维前缀和，我们可以在常数时间内计算任意子矩阵的和。例如，给定一个矩形区域 `(x1, y1)` 到 `(x2, y2)`，它的和可以通过以下公式计算：

sum(x1,y1,x2,y2)=prefix[x2+1][y2+1]−prefix[x1][y2+1]−prefix[x2+1][y1]+prefix[x1][y1]sum(x1, y1, x2, y2) = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]

这个公式通过前缀和矩阵中的四个元素，快速求出任意矩形区域的和。

### 5. **实现示例**

假设我们有如下的二维数组 `matrix`：

```cpp
matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

我们可以按以下方式计算二维前缀和：

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int m = 3, n = 3;
    vector<vector<int>> matrix = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };
    
    // 构建前缀和数组
    vector<vector<int>> prefix(m + 1, vector<int>(n + 1, 0));
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            prefix[i][j] = matrix[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1];
        }
    }
    
    // 查询 (1, 1) 到 (2, 2) 的区域和
    int x1 = 1, y1 = 1, x2 = 2, y2 = 2;
    int sum = prefix[x2 + 1][y2 + 1] - prefix[x1][y2 + 1] - prefix[x2 + 1][y1] + prefix[x1][y1];
    cout << "Sum of submatrix (" << x1 << "," << y1 << ") to (" << x2 << "," << y2 << ") is: " << sum << endl;
    
    return 0;
}
```

### 6. **复杂度分析**

- **构建前缀和矩阵**：需要遍历整个 `matrix` 数组，时间复杂度是 O(m * n)。
- **查询任意子矩阵的和**：每次查询通过前缀和数组可以在 O(1) 的时间内得到结果。

### 7. **总结**

二维前缀和是一种高效的技术，通过预计算前缀和矩阵，使得在查询矩形区域和时，可以将时间复杂度从 O(m * n) 降低到 O(1)，大大提高了查询效率，适用于需要频繁查询子矩阵和的问题。

----
好的，我们来详细且直观地理解**二维前缀和**的构造原理。

### 1. **什么是二维前缀和？**

二维前缀和其实是一个通过**预处理**构建出来的矩阵，使得我们能够在常数时间内计算出二维矩阵中的任意一个子矩形区域的元素和。它是基于一维前缀和的原理，应用到二维数组上。

### 2. **二维矩阵中的前缀和：**

首先，假设我们有一个二维数组 `matrix`，例如：

```
matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

我们希望能够快速查询某个矩形区域内（比如从 `(0, 0)` 到 `(2, 2)`）的元素和。

### 3. **二维前缀和矩阵的构建：**

构建二维前缀和的关键是：**将每个位置的值，累加到该位置之前的区域**，并且同时避免重复计算。具体来说，前缀和矩阵 `prefix` 中的每个元素 `prefix[i][j]`，表示的是从左上角 `(0, 0)` 到当前位置 `(i, j)` 的矩形区域内的元素和。

#### 3.1. **直观解释**

- **`prefix[i][j]`** 的值是包含了两个部分：
    1. **当前位置的值**：即 `matrix[i][j]`。
    2. **上方和左方的和**：即之前已经计算过的区域（上面和左边区域的和），但注意，重复的部分要被减去。

所以，二维前缀和矩阵的计算公式为：

prefix[i][j]=matrix[i][j]+prefix[i−1][j]+prefix[i][j−1]−prefix[i−1][j−1]prefix[i][j] = matrix[i][j] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]

解释：

- `matrix[i][j]` 是当前位置的值。
- `prefix[i-1][j]` 是上方的所有元素的和（当前行前面的部分）。
- `prefix[i][j-1]` 是左侧的所有元素的和（当前列前面的部分）。
- `prefix[i-1][j-1]` 是左上角的区域（被重复计算了，所以要减去）。

#### 3.2. **举例说明**

假设我们要构建以下二维矩阵的前缀和：

```
matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
```

我们可以从左上角开始逐个计算二维前缀和矩阵 `prefix`。

**步骤：**

1. 初始化一个全为 0 的矩阵 `prefix`，它的大小和 `matrix` 一样：

```
prefix = {
    {0, 0, 0},
    {0, 0, 0},
    {0, 0, 0}
};
```

2. 计算第一行第一列的前缀和：

```
prefix[0][0] = matrix[0][0] = 1
```

`prefix` 更新为：

```
prefix = {
    {1, 0, 0},
    {0, 0, 0},
    {0, 0, 0}
};
```

3. 计算第一行第二列的前缀和：

```
prefix[0][1] = matrix[0][1] + prefix[0][0] = 2 + 1 = 3
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 0},
    {0, 0, 0},
    {0, 0, 0}
};
```

4. 继续填充第一行第三列的前缀和：

```
prefix[0][2] = matrix[0][2] + prefix[0][1] = 3 + 3 = 6
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {0, 0, 0},
    {0, 0, 0}
};
```

5. 现在，转到第二行，计算第二行第一列的前缀和：

```
prefix[1][0] = matrix[1][0] + prefix[0][0] = 4 + 1 = 5
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {5, 0, 0},
    {0, 0, 0}
};
```

6. 接下来，计算第二行第二列的前缀和：

```
prefix[1][1] = matrix[1][1] + prefix[0][1] + prefix[1][0] - prefix[0][0]
             = 5 + 3 + 5 - 1 = 12
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {5, 12, 0},
    {0, 0, 0}
};
```

7. 最后，继续填充第二行第三列的前缀和：

```
prefix[1][2] = matrix[1][2] + prefix[0][2] + prefix[1][1] - prefix[0][1]
             = 6 + 6 + 12 - 3 = 21
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {5, 12, 21},
    {0, 0, 0}
};
```

8. 继续计算第三行，第三行第一列的前缀和：

```
prefix[2][0] = matrix[2][0] + prefix[1][0] = 7 + 5 = 12
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {5, 12, 21},
    {12, 0, 0}
};
```

9. 计算第三行第二列的前缀和：

```
prefix[2][1] = matrix[2][1] + prefix[1][1] + prefix[2][0] - prefix[1][0]
             = 8 + 12 + 12 - 5 = 27
```

`prefix` 更新为：

```
prefix = {
    {1, 3, 6},
    {5, 12, 21},
    {12, 27, 0}
};
```

10. 最后，计算第三行第三列的前缀和：

```
prefix[2][2] = matrix[2][2] + prefix[1][2] + prefix[2][1] - prefix[1][1]
             = 9 + 21 + 27 - 12 = 45
```

最终的前缀和矩阵为：

```
prefix = {
    {1, 3, 6},
    {5, 12, 21},
    {12, 27, 45}
};
```

### 4. **如何用前缀和求子矩形的和？**

通过前缀和矩阵，我们可以在常数时间内计算任意子矩形区域的和。

假设我们要求子矩形从 `(x1, y1)` 到 `(x2, y2)` 的和，可以通过以下公式快速计算：

sum(x1,y1,x2,y2)=prefix[x2+1][y2+1]−prefix[x1][y2+1]−prefix[x2+1][y1]+prefix[x1][y1]\text{sum}(x1, y1, x2, y2) = prefix[x2+1][y2+1] - prefix[x1][y2+1] - prefix[x2+1][y1] + prefix[x1][y1]

#### 例如：

我们要求从 `(1, 1)` 到 `(2, 2)` 的和：

```
sum(1, 1, 2, 2) = prefix[2+1][2+1] - prefix[1][2+1] - prefix[2+1][1] + prefix[1][1]
                = prefix[3][3] - prefix[1][3] - prefix[3][1] + prefix[1][1]
                = 45 - 21 - 12 + 3 = 15
```

### 5. **总结**

- **二维前缀和矩阵**是一种通过动态累加前面的区域和来构造的矩阵，它允许我们快速查询任意子矩形的元素和。
- **构造原理**：通过前面的行和列的数据来累加当前元素的值，避免重复计算。
- **查询**：可以在常数时间内通过前缀和矩阵求出任何子矩形区域的和。

希望这样逐步地解释能让你对二维前缀和的原理有一个更加直观和清晰的理解！