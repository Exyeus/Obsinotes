在C++中，正则表达式是通过`<regex>`库提供的，可以用来进行模式匹配、查找和替换等操作。正则表达式对于文本的复杂匹配非常有用，特别是在需要提取特定格式的字符串时。

### 目标：

从字符串 `"10.28.30./*7.-@"` 中提取出：

1. **整数**（例如 10, 28, 30, 7）
2. **四种运算符**（`+`, `-`, `*`, `/`）

### 示例：使用 C++ 正则表达式提取整数和运算符

```cpp
#include <iostream>
#include <string>
#include <regex>
#include <vector>

int main() {
    std::string str = "10.28.30./*7.-@";

    // 定义正则表达式
    std::regex int_regex("\\d+");  // 匹配整数
    std::regex op_regex("[+\\-*/]");  // 匹配运算符 +, -, *, /

    // 用于存储结果
    std::vector<int> numbers;
    std::vector<std::string> operators;

    // 提取整数
    auto it = str.begin();
    std::smatch match;
    while (std::regex_search(it, str.end(), match, int_regex)) {
        numbers.push_back(std::stoi(match.str()));  // 将匹配的字符串转为整数并存入vector
        it = match[0].second;  // 更新迭代器，继续查找
    }

    // 提取运算符
    it = str.begin();  // 重置迭代器
    while (std::regex_search(it, str.end(), match, op_regex)) {
        operators.push_back(match.str());  // 将匹配到的运算符存入vector
        it = match[0].second;  // 更新迭代器，继续查找
    }

    // 输出提取的整数
    std::cout << "Extracted integers: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    // 输出提取的运算符
    std::cout << "Extracted operators: ";
    for (const std::string& op : operators) {
        std::cout << op << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 输出结果：

```
Extracted integers: 10 28 30 7
Extracted operators: / * - 
```

### 解释：

- `std::regex int_regex("\\d+")` 用来匹配一个或多个数字（整数）。其中 `\\d` 表示数字，`+` 表示匹配一个或多个。
- `std::regex op_regex("[+\\-*/]")` 用来匹配运算符。注意：在正则表达式中，`+`, `-`, `*`, `/` 都是特殊字符，必须加上反斜杠（`\\`）才能进行匹配。

### 正则表达式的详细解释：

1. **整数匹配：**
    - `\\d+`：`\\d` 匹配任何数字字符（0-9），而 `+` 表示匹配一个或多个数字。因此，这个表达式可以匹配任何连续的数字串。
2. **运算符匹配：**
    - `[+\\-*/]`：方括号表示字符集，匹配方括号中的任意一个字符。由于 `+`, `-`, `*`, `/` 是特殊字符，在正则表达式中必须进行转义，所以它们分别用 `\\+`, `\\-`, `\\*`, `\\/` 来表示。

### C++ 正则表达式的其他用法：

C++的正则表达式库非常强大，支持多种匹配和替换操作。以下是一些常用的功能和技巧：

#### 1. **查找所有匹配项**

- 通过 `std::regex_search()` 或 `std::regex_match()` 来查找匹配项。

#### 2. **替换匹配项**

- 使用 `std::regex_replace()` 来替换匹配的部分。例如，将文本中的所有数字替换为 "NUM"。

```cpp
std::string str = "10.28.30./*7.-@";
std::regex int_regex("\\d+");
std::string result = std::regex_replace(str, int_regex, "NUM");
std::cout << result << std::endl;  // 输出：NUM.NUM.NUM./*NUM.-@
```

#### 3. **匹配整个字符串**

- 使用 `std::regex_match()` 来确保整个字符串符合正则表达式的模式。

```cpp
std::regex regex("^[a-zA-Z]+$");  // 仅匹配纯字母字符串
if (std::regex_match("Hello", regex)) {
    std::cout << "Match!" << std::endl;
}
```

#### 4. **匹配特定字符或字符集**

- 使用方括号来定义字符集。例如，`[a-z]` 匹配小写字母，`[A-Z]` 匹配大写字母。

```cpp
std::regex regex("[a-z]+");
std::string test = "hello";
if (std::regex_match(test, regex)) {
    std::cout << "Match!" << std::endl;
}
```

#### 5. **捕获分组**

- 使用小括号来定义捕获组。通过分组可以提取匹配的特定部分。

```cpp
std::regex regex("(\\d+)/(\\d+)");
std::string test = "10/20";
std::smatch match;
if (std::regex_match(test, match, regex)) {
    std::cout << "Numerator: " << match[1] << ", Denominator: " << match[2] << std::endl;
}
```

输出：

```
Numerator: 10, Denominator: 20
```

#### 6. **使用量词（Quantifiers）**

- `*`：匹配零个或多个。
- `+`：匹配一个或多个。
- `?`：匹配零个或一个。
- `{n}`：精确匹配n个。
- `{n,}`：匹配至少n个。
- `{n,m}`：匹配n到m个。

```cpp
std::regex regex("\\d{3,5}");  // 匹配3到5个数字
std::string test = "12345";
if (std::regex_match(test, regex)) {
    std::cout << "Match!" << std::endl;
}
```

#### 7. **匹配开头和结尾**

- `^`：匹配行的开始。
- `$`：匹配行的结束。

```cpp
std::regex regex("^Hello.*$");
std::string test = "Hello, World!";
if (std::regex_match(test, regex)) {
    std::cout << "Match!" << std::endl;
}
```

C++中的正则表达式库遵循了基本的正则表达式语法标准，提供了一些特殊符号、字符集和控制符。下面是对正则表达式常见语法的详细讲解。

### 基本语法

1. **字符匹配：**
    - `a`：匹配字符 `a`。
    - `.`：匹配任意单个字符（除了换行符）。
    - `[]`：字符集，用来匹配方括号中的任何单个字符。例如：
        - `[abc]`：匹配字符 `a`、`b` 或 `c` 中的任意一个字符。
        - `[a-z]`：匹配所有小写字母（从 `a` 到 `z`）。
        - `[^0-9]`：匹配任何不是数字的字符（`^` 表示否定）。
2. **字符类别：**
    - `\d`：匹配任何数字，等同于 `[0-9]`。
    - `\D`：匹配任何非数字字符，等同于 `[^0-9]`。
    - `\w`：匹配任何字母、数字或下划线，等同于 `[a-zA-Z0-9_]`。
    - `\W`：匹配任何非字母、数字或下划线，等同于 `[^a-zA-Z0-9_]`。
    - `\s`：匹配任何空白字符（包括空格、制表符、换行符等）。
    - `\S`：匹配任何非空白字符。
    - `\b`：匹配单词的边界（例如，空格、标点符号等地方）。
    - `\B`：匹配非单词边界。

### 量词（Quantifiers）

量词控制着正则表达式如何匹配字符的数量。常用的量词包括：

- `*`：匹配零个或多个前面的元素。例如，`a*` 可以匹配 `""`（空字符串）、`a`、`aa` 等。
- `+`：匹配一个或多个前面的元素。例如，`a+` 可以匹配 `a`、`aa`、`aaa` 等，但不能匹配空字符串。
- `?`：匹配零个或一个前面的元素。例如，`a?` 可以匹配 `""`（空字符串）和 `a`。
- `{n}`：精确匹配前面的元素出现 `n` 次。例如，`a{3}` 匹配 `aaa`。
- `{n,}`：匹配前面的元素出现至少 `n` 次。例如，`a{2,}` 可以匹配 `aa`、`aaa`、`aaaa` 等。
- `{n,m}`：匹配前面的元素出现 `n` 到 `m` 次。例如，`a{2,4}` 可以匹配 `aa`、`aaa` 或 `aaaa`。

### 边界匹配

- `^`：匹配字符串的开始。例如，`^abc` 只会匹配以 `abc` 开头的字符串。
- `$`：匹配字符串的结束。例如，`abc$` 只会匹配以 `abc` 结尾的字符串。
- `\b`：匹配单词边界。例如，`\bword\b` 可以匹配 `word` 但不会匹配 `sword`。

### 分组和捕获

分组用圆括号 `()` 来实现，用于将正则表达式的某部分括起来，便于后续操作或提取。

- `()`：用圆括号来定义一个捕获组。例如，`(abc)` 会捕获子字符串 `abc`。
- `(?:...)`：非捕获分组，只用于分组而不捕获。例如，`(?:abc)` 会匹配 `abc`，但是不会捕获它。
- `\1, \2, \3, ...`：反向引用，表示对捕获组的引用。例如，`(abc)\1` 会匹配 `abcabc`。

### 例子：

- `(\d+)\s+`：此正则表达式会匹配一个或多个数字后跟一个或多个空白字符。
    - 捕获组 `(\d+)` 匹配数字，`\s+` 匹配一个或多个空白字符。

### 断言（Assertions）

正则表达式支持零宽断言（zero-width assertions），即通过断言来匹配某些位置，但不消耗输入字符。

- **前瞻断言（Positive Lookahead）**：`X(?=Y)` 表示匹配 `X`，但只有在它后面跟着 `Y` 时才匹配。
    - 示例：`\d+(?=\s)` 匹配数字后面跟着一个空白字符。
- **负前瞻断言（Negative Lookahead）**：`X(?!Y)` 表示匹配 `X`，但只有在它后面不跟着 `Y` 时才匹配。
    - 示例：`\d+(?!\s)` 匹配数字后面不跟着空白字符。

### 示例：正则表达式用法

假设我们要从字符串中提取出**整数**、**运算符**、**标点符号**和**字母**，并进一步解释每个正则表达式的语法。

#### 1. 提取整数

正则表达式：`\\d+`

- `\\d` 匹配数字字符。
- `+` 匹配一个或多个数字。

#### 2. 提取运算符（`+`, `-`, `*`, `/`）

正则表达式：`[+\\-*/]`

- `[]` 表示字符集，匹配方括号中的任意一个字符。
- `+`、`-`、`*`、`/` 都是运算符，在正则表达式中需要进行转义，因为它们是特殊字符。
    - `\\+`：匹配加号。
    - `\\-`：匹配减号。
    - `\\*`：匹配星号。
    - `\\/`：匹配斜杠。

#### 3. 提取字母

正则表达式：`[a-zA-Z]`

- `[a-zA-Z]` 匹配任何单个字母（大小写字母都可以）。

#### 4. 提取标点符号（例如，`.`）

正则表达式：`[\\.!?]`

- `\\.` 匹配句号（点符号）。在正则表达式中，点号 `.` 是特殊字符，表示匹配任意字符，所以需要用反斜杠进行转义。

### 总结

正则表达式是一个强大的工具，能够在字符串中进行模式匹配。通过使用字符集、量词、分组、边界匹配、断言等特性，我们可以非常灵活地从文本中提取或替换内容。在C++中，通过`std::regex`，我们可以利用正则表达式来处理复杂的字符串匹配任务。在使用正则表达式时，理解每个符号和语法规则的作用至关重要，可以帮助你更高效地使用正则表达式处理文本数据。