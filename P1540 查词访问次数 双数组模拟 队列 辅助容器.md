---
sr-due: 2025-04-10
sr-interval: 35
sr-ease: 270
---

#review 
 P1540 [NOIP 2010 提高组] 机器翻译
 题目背景

NOIP2010 提高组 T1
 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。
这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。
假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。
假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

##### 输入格式
共 $2$ 行。每行中两个数之间用一个空格隔开。
第一行为两个正整数 $M,N$，代表内存容量和文章的长度。
第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。
##### 输出格式
一个整数，为软件需要查词典的次数。
##### 输入输出样例 #1
##### 输入 #1
```
3 7
1 2 1 5 4 4 1
```
##### 输出 #1
```
5
```
##### 说明/提示
##### 样例解释
整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：
1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。
共计查了 $5$ 次词典。

[[LUOGU_TREE]]

```cpp
#include <queue>
#include <iostream>
#include <unordered_set>
  
using namespace std;
queue<int> memory;
unordered_set<int> auxillary_memory;
int main()
{
    int store, wordsum, search_time;
    cin >> store >> wordsum;
    while (wordsum-- > 0)
    {
        int given_word;
        cin >> given_word;
        // This words should suffer the judge from the 2 containers
        if (auxillary_memory.find(given_word) == auxillary_memory.end())
        // if it does not exist
        {
            if (memory.size() == store)
            // if full, remove one and add one
            {
                int to_delete = memory.front();
                memory.pop();
                auxillary_memory.erase(to_delete);
                memory.push(given_word);
                auxillary_memory.insert(given_word);
!注意, 要确保一次操作请求, 在两个容器内都得到了执行!
            }
            else if (memory.size() < store)
            {
                memory.push(given_word);
                auxillary_memory.insert(given_word);
            }
            search_time ++;
        }
        else if (auxillary_memory.find(given_word) != auxillary_memory.end())
        // This word has been read in
        {
            ;
        }
  
    }
    cout << search_time;
    return 0;
}
```

#洛反思 

可以通过 `unordered_set` 来辅助补全 `queue` <font color="#31d83b">查找能力低下的弊端, 但是务必要做好操作的同步</font>
下面是大佬的代码:
### 代码解析

#### 1. **变量声明和初始化**

```cpp
int n, m, x, ans, l, r, a[1005], b[1005];
```

- `n`：请求的总数（即元素总数）。
- `m`：缓存的最大容量（最多可以存放多少个不同的元素）。
- `x`：当前处理的元素。
- `ans`：不同元素的数量。
- `l` 和 `r`：指针，用于表示缓存的区间。
    - `l`：指向缓存区间的左边界（最旧的元素）。
    - `r`：指向缓存区间的右边界（最新的元素）。
- `a[1005]`：一个数组，用来记录每个元素是否在缓存中。`a[x]` 为 1 表示元素 `x` 在缓存中，0 表示不在缓存中。
- `b[1005]`：一个数组，用来存储缓存的元素，模拟一个缓存区。

#### 2. **输入**

```cpp
cin >> m >> n;
l = 0; r = 0; // 初始化两个指针
```

- 通过 `cin` 输入 `m` 和 `n`，`m` 是缓存容量，`n` 是请求的数量。
- `l = 0` 和 `r = 0` 初始化左右指针，表示缓存当前为空。

#### 3. **读入请求并模拟缓存操作**

```cpp
for (int i = 1; i <= n; i++)
{
    scanf("%d", &x); // 边读入边做
    if (a[x] == 0)
    {
        ans++;
        r++;
        b[r] = x;
        a[x] = 1; // 因为每次遇到新单词都要做这些操作，不如搬到判断语句外做，这样程序更简洁
        if (r > m)
        {
            l++;
            a[b[l]] = 0;
        }
    }
}
```

- 通过 `scanf` 逐个读取 `n` 个请求，假设请求是一个整数 `x`。
- **`if (a[x] == 0)`**：判断元素 `x` 是否已经在缓存中。如果不在缓存中，执行以下操作：
    1. **`ans++`**：增加不同元素的数量。
    2. **`r++`**：将 `r` 指针向右移动，表示新元素将被加入到缓存的末尾。
    3. **`b[r] = x`**：将新元素 `x` 添加到缓存数组 `b` 中。
    4. **`a[x] = 1`**：将 `a[x]` 设置为 1，表示元素 `x` 已经进入缓存。
- **`if (r > m)`**：如果缓存的元素个数超过了容量 `m`，就需要移除最早加入的元素：
    1. **`l++`**：将 `l` 向右移动，表示删除缓存中最旧的元素。
    2. **`a[b[l]] = 0`**：将缓存中移除的元素标记为不在缓存中。

#### 4. **输出结果**

```cpp
cout << ans;
```

- 输出不同元素的数量 `ans`，即缓存中存储的不同元素的个数。

#### 5. **返回**

```cpp
return 0;
```

- 程序正常结束，返回 `0`，这是 C++ 主函数的标准结束语句。

### 代码功能总结

这段代码实现了一个基于<font color="#31d83b">LRU（最近最少使用）算法的缓存模拟，主要目标是</font>：

1. **输入**：读取 `m` 和 `n`，其中 `m` 是缓存的最大容量，`n` 是请求的总数。接着输入 `n` 个请求元素。
2. **缓存模拟**：维护一个缓存，缓存最多存放 `m` 个不同的元素。如果新元素未在缓存中，则将其添加到缓存中。如果缓存已满，则移除最早的元素。
3. **输出**：输出经过处理后的不同元素的数量。

### 代码逻辑细节

- **`a[x] == 0` 判断**：如果元素 `x` 不在缓存中，执行相应操作，将其加入缓存，并统计新增的不同元素。
- **LRU 操作**：当缓存超过最大容量 `m` 时，移除最旧的元素。这通过 `l` 和 `r` 指针实现。
- **数组 `a` 和 `b`**：
    - `a` 用来标记每个元素是否在缓存中（`a[x] = 1` 表示在缓存中，`a[x] = 0` 表示不在缓存中）。
    - `b` 用来模拟缓存中元素的顺序，`b[r]` 存储当前缓存中的最新元素。

### 优化和简化

代码的简化主要体现在通过将重复的操作（如更新 `a[x] = 1` 和 `b[r] = x`）集中到 `if (a[x] == 0)` 语句中，这样可以减少冗余代码，使得程序更简洁易懂。