# 8.1 内联函数
```cpp
inline double square(double x) {return x * x;}
```
特点: 函数不再独立存在, 而是可以被主函数直接调用, 这样在一定情况下, 使用之能够加快程序运行.
类似于宏, 但是缺点是会更加占用内存, 属于是用时间去换空间. 调用十次就会有十个副本.

# 8.2 引用变量
引用是已定义的变量的别名, 这样就可以交替使用两个名字来表示这个变量
```cpp
int rats; int & rodents = rats;
这里使用&不是地址运算符,而是一种类型表示,正如*可以是乘法运算符, 但是到了定义处,就变成了对变量是指针类型的指示
```
>rats 和 rodents 从此指向了相同的值和内存单元.
>声明引用的同时必须将其初始化
>对二者之一进行操作都将对其背后的变量造成影响
>使用指针指向二者之一进行的操作也都将对背后同一的这个变量带来影响

不能把一个引用指向另一个变量. 看似成功改变了数值, 实际上导致的是所有的经由引用关联的变量遭到修改
### 将引用作为函数的参数
```cpp
void grumpy(int &x)
int main()
{
	int times = 20;
	grumpy(times);
}
void grumpy(int &x)
{...}
```
## GPT的说法
在C++中，引用（reference）是一种与指针类似的机制，但它更简洁、更直观。引用通过创建一个变量的别名，使得原始变量可以直接被修改。引用有很多应用场景，其中一个重要的用途就是作为函数参数。下面详细讲解引用类型以及将引用作为函数参数的应用价值：

### 1. **C++ 引用类型**


引用是一个别名，它与被引用的对象共享内存地址。创建引用时，必须在声明时初始化，并且一旦绑定到某个对象，不能再绑定到其他对象。

```cpp
int a = 10;
int &ref = a;  // ref是a的引用，现在ref和a指向相同的内存地址
```

### 2. **引用作为函数参数的应用价值**

#### (1) **避免不必要的复制**

当对象较大时（比如大数组、大结构体等），如果每次都传递对象的副本，性能会受到影响。通过引用传递，可以避免复制，直接操作原始数据。

```cpp
void modifyArray(int &arr) {
    arr[0] = 100;  // 直接修改原数组的第一个元素
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    modifyArray(arr);
    // arr[0] 现在是 100
}
```

**应用价值**：减少内存消耗，特别是在处理大对象时，避免不必要的复制操作，提高效率。

#### (2) **可以修改传入的参数**

引用类型允许函数修改传入的参数，因为函数接收到的是原始对象的引用，而非副本。

```cpp
void increment(int &num) {
    num++;  // 修改原始变量
}

int main() {
    int x = 5;
    increment(x);  // x 变为 6
}
```

**应用价值**：引用传递使得函数能够返回多个结果，或者直接修改调用者的变量。

#### (3) **提高代码的可读性和可维护性**

与指针相比，引用在语法上更简洁、更直观，不需要解引用操作，代码更加清晰易懂。

```cpp
void print(const std::string &str) {
    std::cout << str << std::endl;
}
```

**应用价值**：引用语法更简单，比指针易于理解和使用，减少了指针操作的复杂性。

#### (4) **与常量引用结合使用时避免不必要的复制**

当传递参数时，如果不需要修改参数，可以使用常量引用。这样不仅避免了不必要的复制，还保证了函数内部不会修改传入的对象。

```cpp
void printVector(const std::vector<int> &vec) {
    for (int val : vec) {
        std::cout << val << " ";
    }
}
```

**应用价值**：常量引用有效避免了不必要的复制，并且保证了数据的不可修改性，增强了代码的安全性。

### 3. **总结**

- **性能**：引用传递避免了复制，提高了性能，尤其是在处理大型数据结构时尤为重要。
- **修改参数**：引用传递允许函数修改传入的参数，可以作为返回多个结果的机制。
- **简洁与可读性**：相比指针，引用在语法上更加简洁、易于理解，减少了出错的风险。
- **安全性**：常量引用提供了一种只读传递参数的方式，防止意外修改数据。

引用作为函数参数在C++中有着非常广泛的应用，它提高了性能、可读性，并且提供了灵活的编程方式。


## 注意调用后的副作用
```c
double cube_with_value(double x)
{
	x *= x*x;
	return x;
}
double cube_with_reference(double &x) 
// using cube_with_reference(x + 1.0) prohibited, due to this expression is not a variable!w
{
	x *= x*x;
	return x
}
后面这个将会造成 x 在 main 函数之中数值的改变, 而第一个就不会
```