我们从基础开始，逐步分析二维数组的调用方法、`int (*p)[3]` 的含义及其与 `int *p[3]` 的区别。

---

### **1. 二维数组的存储和调用方法**

#### **二维数组的声明**

`int a[2][3];` 表示一个二维数组，有 2 行 3 列，总共 6 个元素。  
在内存中，二维数组是按照行优先存储的，即：

```
a[0][0], a[0][1], a[0][2], a[1][0], a[1][1], a[1][2]
```

- 每行包含 3 个元素。
- 行下标为 `i`，列下标为 `j`，访问某个元素的值使用 `a[i][j]`。

#### **二维数组的指针表达式**

在 C 语言中，二维数组的本质是 **指针数组**，通过指针可以访问元素：

1. `a` 是二维数组首地址，对应类型是 `int (*)[3]`，即指向一个包含 3 个 `int` 类型元素的指针。
2. `a[i]` 等价于 `*(a + i)`，表示第 `i` 行的首地址。
3. `a[i][j]` 等价于 `*(*(a + i) + j)`，即第 `i` 行第 `j` 列的值。

---

### **2. `int (*p)[3]` 的含义**

1. `int (*p)[3]` 表示 `p` 是一个指针，指向一个包含 3 个 `int` 元素的数组。
2. 如果 `p = a;`，则 `p` 指向 `a[0]`，也就是二维数组 `a` 的第 0 行。

#### **通过 `p` 访问二维数组的元素**

- `p + 1` 表示指针移动到二维数组的下一行，即指向 `a[1]`。
- `*(p + 1)` 解引用，得到第 1 行的首地址（即指针 `a[1]`）。
- `*( *(p + 1) + j )` 表示第 1 行第 `j` 列的值。

---

### **3. `int *p[3]` 的含义**

`int *p[3]` 表示 `p` 是一个包含 3 个 `int *` 类型指针的数组。

- 每个元素 `p[i]` 是一个指针，指向一个 `int` 类型变量。
- 它与 `int (*p)[3]` 完全不同。

**区别总结：**

1. `int (*p)[3]` 是指针，指向一个数组（包含 3 个 `int` 元素）。
2. `int *p[3]` 是一个指针数组，包含 3 个 `int *` 类型的指针。

---

### **4. 回到题目分析**

#### **题目中的定义**

```c
int a[2][3], (*p)[3];
p = a;
```

- `p` 是一个指针，指向包含 3 个元素的 `int` 数组。
- `p = a`，则 `p` 指向二维数组的第 0 行，即 `p == a`。

#### **选项分析**

1. **A. `(p + 1)[0]`**
    
    - `(p + 1)` 指向二维数组的第 1 行（即 `a[1]`）。
    - `(p + 1)[0]` 等价于 `*(p + 1)`，表示第 1 行的首地址（即 `a[1]`）。
    - 这是一个错误的访问方式，因为索引 `[0]` 没有意义。
2. **B. `*(*(p + 2) + 1)`**
    
    - `(p + 2)` 超出二维数组的范围（二维数组只有两行）。
    - 解引用会导致越界访问，这是错误的。
3. **C. `*(p[1] + 1)`**
    
    - `p[1]` 表示第 1 行的首地址（即 `a[1]`）。
    - `p[1] + 1` 指向第 1 行第 1 列的地址。
    - `*(p[1] + 1)` 解引用，获取第 1 行第 1 列的值。
    - **这是正确的。**
4. **D. `p[1] + 2`**
    
    - `p[1]` 是第 1 行的首地址，`p[1] + 2` 是第 1 行第 2 列的地址。
    - 但没有解引用操作，因此只是地址而不是值。
    - **这是不完整的表达式。**

---

### **最终答案**

选项 **C** 是正确的。

---

### **背景知识总结**

1. 二维数组的访问：
    
    - 下标法：`a[i][j]`。
    - 指针法：`*(*(a + i) + j)`。
2. `int (*p)[3]` 与 `int *p[3]`：
    
    - `int (*p)[3]` 是指向一行（3 个元素数组）的指针。
    - `int *p[3]` 是指针数组，存储了 3 个指向 `int` 的指针。
3. 指针的移动和解引用：
    
    - `p + 1` 指向下一行。
    - 解引用 `*(p + 1)` 访问下一行。
    - 再次解引用 `*(*(p + 1) + j)` 访问行中的元素。