---
sr-due: 2025-09-21
sr-interval: 165
sr-ease: 290
---

#review 
[[LUOGU_TREE]]

这段程序是经典的 **活动选择问题**（Activity Selection Problem），目的是在给定的一系列活动中选择最大数量的互不重叠的活动。它的核心思想是通过贪心算法来选择合适的活动，以使得可以参与的活动数量最大。下面我将详细分析、讲解该程序，并点评其中使用的高效处理手段。
### 1. **问题背景**
**输入**：
- 一个整数 `n` 表示活动的数量。
- 接下来 `n` 行，每行包含两个整数 `a_i` 和 `b_i`，分别表示活动的开始时间和结束时间。
**输出**
- 最大能够参加的活动数量。
**贪心策略**：
- 选择最早结束的活动，以便为后续活动腾出更多的时间。
### 2. **程序解析**

#### 1. **输入读取**

```cpp
int n;
cin >> n;
vector<pair<int, int>> activities(n);

// 读入活动时间
for (int i = 0; i < n; i++) {
    cin >> activities[i].first >> activities[i].second;
}
```

- **输入解析**：程序首先读入整数 `n`，表示活动的数量。
- 使用 `vector<pair<int, int>>` 存储每个活动的开始时间和结束时间。每个活动是一个 `pair<int, int>`，其中 `first` 存储活动的开始时间，`second` 存储活动的结束时间。

#### 2. **活动排序**

```cpp
sort(activities.begin(), activities.end(), 
    [](const pair<int, int>& a, const pair<int, int>& b) {
        return a.second < b.second;
    });
```

- **排序操作**：对活动按结束时间进行排序。
    - **排序依据**：使用 `a.second < b.second`，即按活动的结束时间排序。贪心策略要求我们优先选择结束时间最早的活动，因为这样可以留出更多的时间给后续活动，从而最大化能参加的活动数。
    - **时间复杂度**：`sort` 的时间复杂度是 O(n log n)，这是活动选择问题中的关键高效步骤。

#### 3. **贪心选择**

```cpp
int count = 1;  // 至少能参加一个活动
int last_end = activities[0].second;  // 记录上一个活动的结束时间

// 贪心选择
for (int i = 1; i < n; i++) {
    if (activities[i].first >= last_end) {
        count++;
        last_end = activities[i].second;
    }
}
```

- **初始化**：从第一个活动开始，至少能参加一个活动，`count` 设置为 1，`last_end` 记录第一个活动的结束时间。
    
- **贪心选择**：
    
    - 从第二个活动开始遍历，对于每一个活动，检查其开始时间是否大于或等于上一个选择活动的结束时间。
    - 如果满足条件，说明当前活动可以参加，则 `count++`，并更新 `last_end` 为当前活动的结束时间。
- **时间复杂度**：贪心过程的时间复杂度是 O(n)，因为只需要遍历一次活动列表。
    

#### 4. **输出结果**

```cpp
cout << count;
```

- 最后输出可以参加的活动数量。

### 3. **高效处理手段**

这段代码的高效性主要体现在以下几个方面：

#### 1. **排序优化**

- **排序** 是该问题的关键步骤，使用了 `std::sort` 对活动按照结束时间进行排序。排序是一个 O(n log n) 的操作，它在时间复杂度上是最主要的瓶颈，但它是解决该问题不可避免的步骤。
- 通过将活动按结束时间排序，保证了贪心选择的正确性，即每次选择结束时间最早的活动，能够为后续活动留出最多的时间。

#### 2. **贪心算法**

- **贪心选择**：通过贪心算法，每次选择最早结束的活动，确保能最大化活动数量。贪心算法的思想简洁且高效，能够在 O(n) 的时间内得出正确的结果。
- **条件判断**：通过简单的 `if (activities[i].first >= last_end)` 判断活动是否可选，这一操作仅需常数时间 O(1)。

#### 3. **时间复杂度**

- **排序**：O(n log n)，对活动进行排序。
- **遍历**：O(n)，遍历已排序的活动列表，做选择。

整体时间复杂度是 O(n log n)，这是解决该问题的最优时间复杂度，因为排序是必须的。

#### 4. **空间复杂度**

- 使用 `vector<pair<int, int>> activities` 存储活动的开始和结束时间，因此空间复杂度是 O(n)，这是标准空间消耗。

### 4. **代码的优点**

- **贪心算法**：使用贪心策略，简单且有效。贪心算法的核心思想是局部最优解（选择结束时间最早的活动）可以推导出全局最优解，且本问题能通过贪心策略正确解决。
    
- **排序优化**：通过排序将活动按结束时间排列，保证每次选择的活动都是能参与的最大数量的一个子集。这是贪心算法的一个经典应用。
    
- **简单易懂**：代码结构清晰，逻辑简单，易于理解。程序没有过度复杂的处理步骤，直接采用了最简单、最有效的贪心方法。
    

### 5. **改进与不足**

- **输入输出优化**：对于大规模数据（如 `n` 可能达到 10^6），虽然在 C++ 中 `cin` 和 `cout` 的效率相对较高，但仍然可以通过 
```cpp
ios::sync_with_stdio(false);
cin.tie(0);
```


来优化输入输出速度，尤其在竞赛中，避免因输入输出慢而影响程序整体运行时间。

```cpp
ios::sync_with_stdio(false);
cin.tie(0);
```

- **内存消耗**：空间复杂度是 O(n)，对于大规模数据可以进一步考虑是否有更小的内存使用方法，但本问题中，`vector<pair<int, int>>` 是存储活动所必须的，因此空间消耗是合理的。

### 6. **总结**

- **算法**：使用了经典的 **贪心算法**，通过对活动按结束时间排序，逐个选择符合条件的活动。
- **时间复杂度**：整体时间复杂度为 O(n log n)，由于排序是瓶颈，因此这是该问题的最优时间复杂度。
- **空间复杂度**：空间复杂度为 O(n)，适合大规模数据处理。

总体而言，这段代码非常高效，适合解决类似活动选择的问题，并能应对最大规模数据（n = 10^6）。