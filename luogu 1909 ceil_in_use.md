---
sr-due: 2025-08-18
sr-interval: 130
sr-ease: 270
---

#review 

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
  
int main()
{
    int n, x1, y1, x2, y2, x3, y3;
    cin >> n >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;
    // n 除以各个 x, 并且利用ceil向上取整
// 计算v1，v2，v3的值
    double v1 = ceil((double)n / x1)*y1; // 计算v1的值，使用ceil函数向上取整
    
 这里不使用 (double)n 就会发生错误!
 
    double v2 = ceil((double)n / x2)*y2; // 计算v2的值，使用ceil函数向上取整
    double v3 = ceil((double)n / x3)*y3; // 计算v3的值，使用ceil函数向上取整
    double mini = 0;
    // 输出 v1, v2, v3 中的最小值
    mini  = min({v1,v2, v3});
    cout << mini << endl;
    return 0;
}
```

## 必须使用`double(n)`是因为`ceil`的性质.

在原代码中，`n` 和 `x1` 都是整数，且在执行 `n / x1` 时，C++ 会进行 **整数除法**。整数除法的规则是，结果将向零取整（也就是舍去小数部分），这就可能导致一些问题，尤其是当我们期望得到浮动值时。

#### 例子：

假设 `n = 10`，`x1 = 3`，在没有改成 `double` 的情况下，`n / x1` 执行的是整数除法：

- `n / x1 = 10 / 3 = 3` （这是整数除法的结果，结果舍去了小数部分）

然后我们用 `ceil(3)` 计算 `v1`，`ceil(3)` 结果是 `3`，这个显然是错误的，因为我们希望得到 `ceil(10 / 3)`，即 `4`。而实际问题是，`10 / 3` 并不是一个整数，它等于 `3.333...`，应该向上取整得到 `4`。

### 为什么改成 `double` 就能正确计算

当我们将 `n` 或 `x1` 中的一个（或多个）操作数改为 `double` 类型时，C++ 将会执行 **浮点除法**，而浮动除法保留了小数部分。

#### 浮点除法的处理方式：

- `n / x1 = 10 / 3` 变成了浮动除法，即 `10.0 / 3`，结果是 `3.333...`，这就保留了小数部分。
- 接下来，我们用 `ceil(3.333...)` 进行向上取整，结果是 `4`，这是我们预期的正确结果。

所以，改成 `double` 使得我们能够正确地保留小数部分，并让 `ceil` 函数按照实际的浮动数进行向上取整，而不是基于已经丢失小数部分的整数值进行操作。

### 总结

- **整数除法** 会丢失小数部分，导致计算结果不准确，特别是当需要浮动值时。
- **浮点除法** 会保留小数部分，保证了正确的取整逻辑。
- 使用 `double` 类型确保了 `ceil` 函数可以操作精确的浮动值，而不是经过整数除法丢失了小数部分的结果。

这就是为什么改成 `double` 后，代码能够正确计算出向上取整的原因。

