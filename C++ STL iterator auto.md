---
sr-due: 2025-11-24
sr-interval: 214
sr-ease: 270
---

#review 

[[LUOGU_TREE]]
这段代码的目标是模拟一个操作列表（`list<int>`）的过程，支持元素的插入和删除。代码中通过 `unordered_map` 存储每个元素的位置，通过 `unordered_set` 来确保每个元素仅删除一次。接下来，我们将逐一分析代码中涉及的链表操作、迭代器的使用、`auto` 关键字和 `advance` 函数。

### 1. 链表操作

- **初始化链表和位置映射**：  
    程序首先初始化一个空的链表 `a`，和一个 `unordered_map` `pos`，用来存储每个元素的迭代器（即该元素在链表中的位置）。
    
    ```cpp
    list<int> a;
    unordered_map<int, list<int>::iterator> pos;
    ```
    
- **插入操作**：  
    初始时，插入一个元素 `1` 到链表的开头。该操作通过 `a.insert(a.begin(), 1)` 实现。返回值是新插入元素的迭代器，我们将其保存在 `pos[1]` 中，以便后续操作。
    
    ```cpp
    auto first_it = a.insert(a.begin(), 1);
    pos[1] = first_it;
    ```
    
    接下来的循环处理插入操作。在每次循环中，程序根据 `operation_type` 判断是左插入还是右插入：
    
    - **左插入**：在 `target_person` 之前插入新元素。通过 `a.insert(pos[target_person], i+2)` 实现。
    - **右插入**：在 `target_person` 之后插入新元素。通过 `a.insert(next(pos[target_person]), i+2)` 实现。`next()` 函数返回的是 `pos[target_person]` 迭代器的下一个位置。 这些插入操作会更新 `pos[i+2]`，确保我们在每次操作后都知道新元素的位置。
    
    ```cpp
    auto insert_it = a.insert(pos[target_person], i+2); // 左插入
    pos[i+2] = insert_it;
    ```
    
    ```cpp
    auto insert_it = a.insert(next(pos[target_person]), i+2); // 右插入
    pos[i+2] = insert_it;
    ```
    
- **删除操作**：  
    在删除操作中，我们首先检查该元素是否已经被删除。如果没有被删除过，使用 `a.erase(pos[removal_object])` 删除对应位置的元素。删除后将该元素标记为已删除，避免重复删除。
    
    ```cpp
    a.erase(pos[removal_object]); // 删除元素
    executed_list.insert(removal_object); // 标记为已删除
    ```
    

### 2. 迭代器的知识

在 C++ 中，迭代器是一种指向容器中元素的对象，它使得我们能够遍历和操作容器的内容。对于链表（`list`）这种容器，迭代器非常重要，<font color="#ffff00">因为链表不是连续内存结构，不能像数组那样直接通过索引访问元素</font>。

- `list<int>::iterator` 是指向 `list<int>` 容器中元素的迭代器类型。
- 使用迭代器时，我们可以通过 `*it` 来访问迭代器所指向的元素，使用 `++it` 来移动迭代器到下一个元素，使用 `it = a.begin()` 来初始化迭代器。

>Python : iterator = iter(iterable_object)

在这段代码中，迭代器 `first_it`、`insert_it` 和 `pos[target_person]` 都是链表操作的关键，通过它们我们可以在链表中定位并操作元素。

### 3. `auto` 关键字

`auto` 关键字是 C++11 引入的，<font color="#ffff00">用于自动推导变量的类型</font>。编译器会根据初始化时赋值的类型来推导出变量的类型，简化了代码的书写，避免了重复指定类型的麻烦。特别是在使用<font color="#ffff00">复杂类型</font>（**如容器迭代器**）时，`auto` 非常方便。

在这段代码中，`auto` 被用于以下地方：

- `auto first_it = a.insert(a.begin(), 1);`  
    这里 `first_it` 的类型是 `list<int>::iterator`，通过 `auto` 关键字，**<font color="#ffff00">编译器</font> 自动推导出类型**，简化了代码。
    
- `auto insert_it = a.insert(pos[target_person], i+2);`  
    同样，`insert_it` 是一个迭代器，`auto` 自动推导出它的类型。
    

使用 `auto` 的好处是：

- <font color="#ffff00"> 避免显式指定复杂的类型，提高代码的简洁性和可读性</font>。
- 如果容器类型或迭代器类型发生变化，程序仍然能保持正确，不需要手动修改所有类型声明。

### 4. `advance` 函数

`advance` 是标准库中用于<font color="#ffff00">移动迭代器的一个函数</font>。<font color="#ffff00">它允许我们根据给定的步长偏移迭代器</font>。比如，`advance(it, 1)` 会将迭代器 `it` 向前移动一位。

但是在这段代码中，`advance` 并没有被使用，取而代之的是 `next()` [[CS61A 2.4 Mutable Data]]函数，它是一个类似的函数，返回迭代器的下一个位置。`next(pos[target_person])` 获取的是 `pos[target_person]` 的下一个迭代器。

`advance` 函数的使用示例：

```cpp
advance(it, 3); // 将迭代器 it 向前移动 3 个位置
```

`next` 函数通常用于获取一个迭代器的“下一个位置”，而 `advance` 更为通用，可以向前或向后移动指定步数。

### 总结

1. **链表操作**：插入操作使用 `insert` 函数，删除操作使用 `erase`，迭代器用于定位和操作元素。
2. **迭代器**：`list<int>::iterator` 类型用于遍历和修改链表。
3. **`auto` 关键字**：简化了代码，避免了显式声明迭代器的类型。
4. **`advance` 和 `next`**：虽然这段代码中使用了 `next`，它与 `advance` 功能相似，主要是操作迭代器的位置。

这段代码的逻辑清晰，结构简单，巧妙地使用了容器和迭代器来实现链表的插入、删除操作，并确保操作的高效性和正确性。

### 1. `advance` 和 `next` 的替代方案

在 C++ 中，`advance` 和 `next` 是常用的<font color="#ffff00">迭代器操作函数，用来在迭代器上进行步进或偏移。虽然这些函数在操作容器时非常便利，但我们仍然可以使用一些替代方案来达到相同的目的</font>。

- **替代 `advance`**：  
    `advance(it, n)` 会使迭代器 `it` 向前或向后移动 `n` 个位置。一个替代方法是直接使用 `++` 或 `--` 操作符循环移动迭代器。
    
    ```cpp
    for (int i = 0; i < n; ++i) {
        ++it; // 向前移动迭代器
    }
    ```
    
    这样每次使用 `++it` 或 `--it` 来移动迭代器，相当于<font color="#ffff00">手动做步进</font>。
    
- **替代 `next`**：  
    `next(it, n)` 返回一个指向迭代器 `it` 向前（或向后）偏移 `n` 个位置的新迭代器。如果不想使用 `next`，可以直接使用 `++` 或 `--`，<font color="#ffff00">但你需要注意对原始迭代器进行修改，而不是返回新的迭代器</font>：
    
    ```cpp
    auto new_it = it;
    for (int i = 0; i < n; ++i) {
        ++new_it; // 将迭代器向前偏移
    }
    ```
    

### 2. 迭代器是什么？

迭代器是 C++ 标准库中用于<font color="#ffff00">遍历容器（如数组、链表、向量等）元素的对象</font>。它类似于指针，但它是与容器类型相关的抽象，通常封装了容器内部的访问机制，<font color="#ffff00">使得代码更加通用和灵活。迭代器允许你通过容器来访问和修改元素，而不必直接处理容器内部的结构细节</font>。

- **功能**：
    
    - **遍历容器**：迭代器提供了一种统一的方式来访问容器中的元素，无论容器的底层实现如何。
    - **支持解引用**：可以使用 `*it` 来获取迭代器指向的元素。
    - **移动**：可以使用 `++`、`--` 操作符来移动到容器中的下一个或上一个元素。
    - **支持随机访问（对于支持的容器，如 `vector`）**：迭代器能够像数组索引一样支持快速定位元素。
    
    示例：
    
    ```cpp
    vector<int> v = {1, 2, 3, 4};
    vector<int>::iterator it = v.begin(); // 获取指向第一个元素的迭代器
    
    // 遍历容器
    for (; it != v.end(); ++it) {
        cout << *it << " ";  // 输出元素的值
    }
    ```

>典范级代码！
```cpp
for (; it != v.end(); ++it)
{
	cout << \*it << "";
}
```

### 3. 迭代器与数组的 `[]` 下标和 `for (int i = 0; i < N; i++)` 中的 `i` 的区别

**数组下标**、**迭代器**和**循环中的 `i`** 都是用于<font color="#ffff00">遍历和访问容器元素的方式，但它们本质上有不同的机制和适用范围</font>。
[[Python Special Methods]]
#### 1) 数组下标（`[]`）

- **适用于连续内存的容器**：数组、`vector` 等都是在内存中连续分布的。使用数组下标 `a[i]` 可以直接通过偏移量（`i`）来访问元素。
    
- **直接操作内存**：通过下标访问元素时，编译器根据数组的地址和下标直接计算出对应元素的位置。对于数组或 `vector` 来说，内存是线性连续的，且支持快速的随机访问。
    
- **限制**：下标<font color="#ffff00">只能用于支持随机访问的容器</font>，如数组和 `vector`。对于链表（`list`）这种非连续的容器，无法直接使用下标。
    
    示例：
    
    ```cpp
    int arr[] = {1, 2, 3, 4};
    cout << arr[2]; // 输出3
    ```
    

#### 2) 迭代器（Iterator）

- **适用于所有容器**：迭代器不仅可以用于 `vector`，也可以用于链表（`list`）、映射（`map`）等容器。
    
- **抽象访问**：迭代器通过抽象的接口提供了一种通用的遍历方式，无论容器是连续还是非连续的。对于链表等非连续内存的容器，迭代器负责管理元素的遍历。
    
- **不支持随机访问**：对于像链表这样的容器，迭代器不支持通过 `i` 快速定位元素。相反，它依赖于在容器中顺序遍历，逐个访问元素。
    
    示例：
    
    ```cpp
    list<int> lst = {1, 2, 3, 4};
    for (auto it = lst.begin(); it != lst.end(); ++it) {
        cout << *it << " ";  // 输出元素的值
    }
    ```
    

#### 3) 循环中的 `i`（`for (int i = 0; i < N; i++)`）

- **通常用于数组和支持随机访问的容器**：`for` 循环中的 `i` 通常作为数组下标或迭代器的步进值。它用来控制访问容器中的每个元素。
    
- **适用于索引**：`i` 是数组或容器的索引，用于直接引用元素。在循环中，`i` 通过步进的方式从容器的开始访问到结束。
    
    示例：
    
    ```cpp
    for (int i = 0; i < 4; i++) {
        cout << arr[i] << " "; // 输出数组元素
    }
    ```
    

### 本质区别总结：

|特性|数组下标 (`[]`)|迭代器|`for` 循环中的 `i`|
|---|---|---|---|
|**适用容器**|仅限于数组和支持随机访问的容器（如 `vector`）|适用于所有容器（`vector`、`list`、`map` 等）|用于数组或支持随机访问的容器的索引|
|**内存访问方式**|直接通过偏移量访问连续内存元素|抽象访问，不依赖内存结构|通过步进操作（通常作为数组下标）访问|
|**是否支持随机访问**|支持|仅支持支持随机访问的容器（如 `vector`）|通常支持（尤其是数组和 `vector`）|
|**效率**|对于连续内存的容器（如 `vector`），非常高效|对于非连续内存的容器（如 `list`），可能较慢|快速，尤其在数组和 `vector` 中|

### 总结：

- **数组下标** 和 **`for` 循环中的 `i`** 主要适用于支持随机访问的容器，它们通过计算偏移量来访问容器元素。
- **迭代器** 提供了一种通用的方式来访问容器元素，尤其适合那些底层结构不连续的容器（如 `list`）。它通过抽象的接口遍历容器，使得代码更具通用性和灵活性。

---

# 一些细节
对于一个迭代器 `it`，以下是几种常见的操作：

- **`it++`**：迭代器自增，<font color="#ffff00">返回当前迭代器的副本，然后将迭代器指向容器中的下一个元素</font>。
- **`it += 1`**：将迭代器向前移动一个位置。这个操作在支持随机访问的容器（如 `vector`、`deque` 等）上有效。
- **`it = it + 1`**：与 `it += 1` 类似，执行的是迭代器加法运算，返回一个新的迭代器，指向当前迭代器的下一个位置。

### 1. `it++`、`it += 1` 和 `it = it + 1` 的区别

- **`it++`（后置递增）**：
    
    - `it++` 是**后置递增**，返回当前的迭代器值，然后自增。
    - 它首先返回迭代器 `it` 指向的元素（即解引用 `*it`），然后使 `it` 指向容器中的<font color="#ffff00">下一个元素</font>。
    - 适用于*所有支持递增操作*的迭代器（即支持*顺序访问*的容器，如 `list`、`vector`）。
    - 该操作是最常用的遍历方式。
    
    示例：
    
    ```cpp
    // 遍历容器，指向下一个元素
    for (auto it = container.begin(); it != container.end(); it++) {
        cout << *it << " "; // 打印当前元素
    }
    ```
    
- **`it += 1` 和 `it = it + 1`（迭代器加法）**：
    
    - **`it += 1`** 是**迭代器加法**，等同于 `it = it + 1`，用于向前移动一个位置。
    - 这种操作更常用于*支持随机访问的容器*（如 `vector`、`deque` 等），因为它需要通过计算偏移量来定位下一个元素。
    - **`it += 1`** 在对迭代器进行加法时，效率较高，因为它是原地修改迭代器本身，而 `it = it + 1` 会创建一个新的迭代器，并且再赋值给原来的变量。
    
    示例：
    
    ```cpp
    // 只有支持随机访问的容器（如 vector）可以使用此操作
    it += 1; // 等同于 it = it + 1，指向下一个元素
    ```
    

### 2. 用于访问容器的迭代器是否只能通过自增自减来变化？

不是，虽然迭代器通常通过自增（`++`）或自减（`--`）来变化，但也有其他方法可以改变迭代器的位置：

- **通过加法运算（`it = it + n` 或 `it += n`）**：这种方式通常适用于支持随机访问的容器，如 `vector`、`deque`，你可以通过步进任意的数量（正数或负数），使迭代器跳到容器中的任意位置。
    
    示例：
    
    ```cpp
    // 只对支持随机访问的容器有效
    it += 3;  // 将迭代器向前移动3个位置
    ```
    
- **通过减法运算（`it = it - n` 或 `it -= n`）**：这种方式也适用于支持随机访问的容器。它与加法相对，向后移动迭代器。
    
    示例：
    
    ```cpp
    // 只对支持随机访问的容器有效
    it -= 2;  // 将迭代器向后移动2个位置
    ```
    
- **`advance(it, n)`**：`advance` 是一个标准库函数，可以通过传递步数 `n` 来改变迭代器的位置，步数 `n` 可以为正数（向前）或负数（向后），这种方式适用于<font color="#ffff00">所有类型的迭代器，无论容器是否支持随机访问</font>。
    
    示例：
    
    ```cpp
    // 适用于所有容器
    advance(it, 3); // 将迭代器向前移动3个位置
    advance(it, -3); // 将迭代器向后移动3个位置
    ```
    

### 3. 哪些可以用于迭代器的访问修改？

迭代器可以用于容器元素的访问和修改，具体如下：

- **访问元素**：通过解引用迭代器来访问当前元素，使用 `*it`。
    
    ```cpp
    cout << *it; // 访问当前元素的值
    ```
    
- **修改元素**：通过解引用迭代器并赋值来修改元素。
    
    ```cpp
    *it = 5; // 修改当前元素的值
    ```
    
- **改变迭代器的位置**：可以使用 `++`、`--`、`+=`、`advance()` 等操作来移动迭代器。
    

### 4. `advance` 的步数如果是负数，是否会往前移动？

是的，`advance` 函数允许使用负数作为步数来将迭代器向后移动。如果传递负数，`advance` 会使迭代器向容器中的前一个元素移动。例如：

```cpp
advance(it, -2); // 向前移动两个位置
```

### 总结

|操作方式|适用场景|描述|
|---|---|---|
|`it++`|所有支持递增操作的容器|后置递增，返回当前迭代器的副本，指向下一个元素|
|`it += 1` 或 `it = it + 1`|主要适用于支持随机访问的容器（如 `vector`、`deque`）|迭代器加法，指向下一个元素|
|`advance(it, n)`|所有容器|根据步数 `n` 移动迭代器，可以是正数或负数|

迭代器的变化并不局限于自增和自减，它也可以通过加法、减法或 `advance()` 来变化。而 `advance` 的步数如果为负数，迭代器会向容器的前一个元素移动，适用于所有类型的迭代器。