优先级队列（Priority Queue）是一种特殊的队列数据结构，支持元素的按优先级顺序访问和删除。它与普通队列不同，普通队列通常是“先进先出”（FIFO）的，而优先级队列则按元素的“优先级”顺序来决定出队的顺序。

### 特点
在优先级队列中，每个元素都有一个与之关联的“优先级”。出队顺序依据优先级：
- 优先级高的元素比优先级低的元素先出队。
- 如果两个元素优先级相同，则可能按插入顺序（先插入的先出队），这具体取决于实现方式。

### 实现方式
优先级队列可以通过多种数据结构来实现，常见的有以下几种：
1. **堆（Heap）**：通常使用**二叉堆**（如最小堆、最大堆）来实现优先级队列，这样可以在 \(O(\log n)\) 时间内完成插入和删除操作。
   - **最小堆**：根节点为最小元素，适用于最小优先级队列，即优先级最小的元素最先出队。
   - **最大堆**：根节点为最大元素，适用于最大优先级队列，即优先级最大的元素最先出队。
2. **二叉搜索树（Binary Search Tree, BST）**：可以使用自平衡二叉搜索树（如红黑树或AVL树）来实现，插入和删除操作的平均时间复杂度为 \(O(\log n)\)。
3. **无序链表**：使用链表保存元素，出队时遍历链表找到优先级最高的元素。插入操作为 \(O(1)\)，但出队操作为 \(O(n)\)。
4. **有序链表**：链表按优先级排序，出队时可以直接取表头元素。插入操作为 \(O(n)\)，出队操作为 \(O(1)\)。

### 常见操作
优先级队列通常支持以下操作：
1. **插入（Insert / Enqueue）**：将一个元素按照其优先级插入队列中。
2. **删除（Delete / Dequeue）**：删除并返回优先级最高的元素。
3. **获取优先级最高的元素（Peek / Top）**：返回优先级最高的元素，但不删除它。

### 应用场景
优先级队列在很多场景中都很有用，特别是需要动态管理优先级的情况下：
1. **任务调度**：操作系统可以根据任务的优先级安排执行顺序。
2. **路径搜索**：如Dijkstra算法中，优先级队列用于选择当前最短路径。
3. **事件模拟**：在模拟系统中，事件按照发生时间（优先级）进行处理。
4. **数据流管理**：处理实时数据时，可以通过优先级队列来保证高优先级的数据先处理。

### 示例代码
在 C++ 中，`priority_queue` 是标准库提供的优先级队列，它默认是最大堆实现（即优先级最高的元素最先出队）：
```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    std::priority_queue<int> pq; // 默认是最大堆

    pq.push(5);
    pq.push(1);
    pq.push(10);
    pq.push(3);

    // 输出元素，按照优先级顺序出队
    while (!pq.empty()) {
        std::cout << pq.top() << " ";  // 输出当前最大元素
        pq.pop();  // 删除最大元素
    }
    // 输出：10 5 3 1
    return 0;
}
```

### 小顶堆实现的优先级队列
在 C++ 中可以使用 `std::priority_queue<int, std::vector<int>, std::greater<int>>` 来构建最小[[堆]]，以实现优先级最低的元素最先出队：
```cpp
#include <iostream>
#include <queue>
#include <vector>

int main() {
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;

    minHeap.push(5);
    minHeap.push(1);
    minHeap.push(10);
    minHeap.push(3);

    while (!minHeap.empty()) {
        std::cout << minHeap.top() << " "; // 输出当前最小元素
        minHeap.pop(); // 删除最小元素
    }
    // 输出：1 3 5 10
    return 0;
}
```

### 总结
优先级队列是一种根据优先级管理元素的数据结构，适用于任务调度、路径搜索、事件模拟等场景。常见的实现方式包括堆和二叉搜索树，选择合适的实现方式可以提升性能。