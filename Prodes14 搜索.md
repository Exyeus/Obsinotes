### Intro
全排列，使用穷举，穷举处理固定的变量
但是不能处理变化数量的变量。如果是Var个变量，则不行，因为不能变量
>搜索是高阶的穷举
>穷举的本质是遍历所有的解空间，得到可行解，然后再得到最优解

## 概述
- 解空间
- 问题的解
- 约束条件
	- 显约束 取值范围
	- 隐约束 得到可行与最优情况得到的约束
- 解空间树与搜索树
- 结点
	- 扩展节点 活结点 死结点 子孙节点 祖先节点
>有一些概念是动态的，因为搜索树是解空间树的子空间，是一个随着搜索过程发生动态改变的数。与上面五个节点的性质密切相关。
- 状态
- 状态转移
	- 确保可行性
	- 确保最优化 $$最优化函数具有单调性，如果确定最优，就可以进行剪枝$$- 避免重复搜索
>与后续的状态标记是否相关？
>是否可以在运行的时候，`calloc`之得到可变大小的指针数组，用来指向后面的那些节点，并且对应进行动态分配。
- 状态共享 通常在父子之间进行
- 搜索策略$$深度优先搜索与宽度优先搜索$$
- 
## 深度优先搜索-递归回溯法
### 基本思想
- 一次一个孩子结点
- 隐约束决定是否深入
- 发现不满足就回溯
- **回溯需要回复原先的状态**
- 不考虑条件
	- 定义状态 `k` `array` `used`
	- 定义递归函数
```c
void dfs(int k)
{
	int i;
	if (k > n)
	{
		output();
		return;
	}
	for (i = 1; i < n; i++)
	{
		if (used[i]) continue;
		ary[k] = i;
		used[i] = 1;
		dfs(k+1);
		used[i] = 0;
	}
}
```
### 八皇后问题 典型的深度优先算法
- 设置值不能只为1,2，因为回溯时修改会导致，如果这里有其他确定的皇后的影响，那么这层影响遭到忽视
- 约束：皇后1~8；放置之时，不可与前面放置之皇后冲突
#### 优化——空间压缩 更改`check_safe` `set_conflict`

### 零件加工问题 最优解的问题
#### 显约束 必须遍历所有的零件
#### 隐约束
- 不能在剩余若干零件的时候，时间已经超过了有记录的最短时间
- 解的各个分量符合排列的要求
设置数值最大`int x = 0xffffffff`

## 广度优先搜索 分支限界法
## ?
## 8-puzzle Problem
- 编码：使用有序整数，而非矩阵
>能否使用指针来处理之？
- 去除重复状态


## BFS DFS COMPARE
- 答案数量多少
- 离根的距离怎么样？（层级）
- 每一层节点数量的多少

## KEY
>条件分为显性和隐形，分别对应是数值范围