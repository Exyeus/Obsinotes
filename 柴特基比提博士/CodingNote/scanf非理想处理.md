`scanf` 函数在处理用户输入时，依据格式字符串从标准输入中读取数据并存储到指定的变量中。输入不理想或用户输入包含错误时，`scanf` 的行为会依照一定的规则来处理这些情况。下面是对非理想状态下 `scanf` 获取数据的规律和行为的详细解释，包括处理类型错误、空格、换行等多种输入情况。
[[数据违规]]
### 1. **输入不符合预设格式时的行为**

#### 1.1. **类型错误**
- 当用户输入的类型与 `scanf` 期望的类型不符时，`scanf` 会停止读取数据并返回读取到的成功项数。如果输入不能匹配第一个预期的类型，则函数返回 `0`。
  
  **示例：**
  ```c
  int num;
  scanf("%d", &num);  // 期望整数
  ```
  如果用户输入 `abc`，`scanf` 会立即返回，`num` 不会被赋值，且返回值为 `0`。输入中的 `abc` 将保留在输入缓冲区，等待下一个 `scanf` 调用。

#### 1.2. **输入部分匹配**
- 如果输入的前部分与格式匹配，但后续部分不匹配，`scanf` 会读取前部分并将不匹配的部分留在缓冲区。

  **示例：**
  ```c
  int num;
  scanf("%d", &num);  // 期望整数
  ```
  用户输入 `123abc`，`scanf` 将成功读取 `123`，`num` 被赋值为 `123`，而 `abc` 将保留在输入缓冲区，供下一个 `scanf` 处理。

### 2. **空格和换行符的处理**

`scanf` 对空格、换行符和制表符的处理方式依赖于输入格式的占位符。它对不同的输入占位符（如 `%d`, `%f`, `%s`）的行为有所不同。

#### 2.1. **空格的自动处理**
- `scanf` 会自动跳过输入中的所有空白字符，包括空格、换行符 (`\n`) 和制表符 (`\t`)，但只在特定类型读取时生效，如 `%d`, `%f`, `%c` 等。
  
  **示例：**
  ```c
  int a, b;
  scanf("%d %d", &a, &b);
  ```
  无论用户输入 `10 20`、`10    20` 或者 `10\n20`，`scanf` 都会成功读取 `10` 和 `20`，自动忽略空格、换行符和制表符。

#### 2.2. **多打空格**
- 如果输入多了空格，`scanf` 几乎总是忽略它们，除非使用 `%c` 格式符来读取字符。

  **示例：**
  ```c
  int a;
  scanf("%d", &a);
  ```
  用户输入 `10      `（后跟多个空格），`scanf` 会成功读取 `10`，并忽略后续的空格。

#### 2.3. **少打空格**
- 如果在读取多个输入项时，用户少打了空格（如连续输入），`scanf` 仍然能够处理。

  **示例：**
  ```c
  int a, b;
  scanf("%d%d", &a, &b);
  ```
  用户输入 `1020`，`scanf` 会读取 `a=10`，`b=20`。但此时要求数据要清晰可分，否则可能会发生读取错误（如输入 `12345` 时，可能会读取 `12` 和 `345`）。

#### 2.4. **换行符（Enter）**
- 在 `%d`, `%f` 等占位符中，`scanf` 会忽略换行符，也就是说输入 `10\n20` 或 `10\n\n20` 效果和输入 `10 20` 相同。

#### 2.5. **制表符（Tab）**
- 制表符 (`\t`) 也被视为空白字符，并且在读取 `%d`, `%f`, `%s` 时会被忽略。
  
  **示例：**
  ```c
  int a, b;
  scanf("%d%d", &a, &b);
  ```
  用户输入 `10\t20`，`scanf` 会成功读取 `10` 和 `20`。

#### 2.6. **使用 `%c` 读取字符时的空格和换行**
- `%c` 格式符用于读取单个字符。它不会跳过空白字符（空格、换行符、制表符），并且会读取它们作为输入字符。

  **示例：**
  ```c
  char ch;
  scanf("%c", &ch);  // 用户输入空格
  ```
  `ch` 的值将是空格 `' '`，而不是下一个可见字符。同样，按下 `Enter` 时，`ch` 会得到换行符 `'\n'`。

#### 2.7. **处理字符串（%s）**
- 当使用 `%s` 来读取字符串时，`scanf` 会跳过输入的前导空白字符（包括空格、换行符、制表符等），但在遇到第一个空格或换行符时停止。

  **示例：**
  ```c
  char str[20];
  scanf("%s", str);
  ```
  用户输入 `"hello world"`，`scanf` 只会读取 `"hello"`，并将 `"world"` 留在输入缓冲区。

### 3. **Backspace (退格键) 的处理**

`scanf` 不会直接处理 `Backspace`，因为 `Backspace` 的行为由终端（或操作系统的输入系统）管理。当用户按下 `Backspace` 时，终端会删除最后一个输入字符，所以 `scanf` 只看到修改后的输入内容。

**示例：**
```c
int num;
scanf("%d", &num);
```
用户输入 `12`，然后按下 `Backspace`，输入变为 `1`。`scanf` 将读取修改后的输入，即 `1`。

### 4. **格式字符串中的空格**

格式字符串中的空格与 `%d`、`%f`、`%s` 等符号一起使用时，会指示 `scanf` 忽略输入中的所有空白字符（包括空格、换行和制表符）。空格可以显式或隐式地包含在格式字符串中。

**示例：**
```c
int a, b;
scanf("%d %d", &a, &b);  // 显式空格
scanf("%d%d", &a, &b);   // 隐式空格，效果相同
```
无论是输入 `10 20` 还是 `10\n20`，结果都是一样的。

### 5. **输入错误时的缓冲区行为**

当输入不符合预期格式时，`scanf` 会停止读取，并将无法处理的输入保留在缓冲区中。下一个 `scanf` 调用会继续读取剩余的输入。

**示例：**
```c
int a;
scanf("%d", &a);  // 输入 "abc123"
```
此时 `scanf` 无法将 `abc` 转换为整数，因此会停止读取。`abc` 将保留在缓冲区中，下一个 `scanf` 调用时会继续读取这个未处理的部分。

### 6. **错误处理**

当 `scanf` 遇到格式不匹配或读取错误时，它会返回读取的成功项数或 `EOF`（如果读取到文件结束）。例如，如果期望读取一个整数但输入了非数字字符，`scanf` 将返回 `0`，表示没有成功读取到任何有效项。

```c
int num;
int ret = scanf("%d", &num);  // 用户输入 "abc"
if (ret == 0) {
    printf("读取失败\n");
}
```

### 总结
- **空格、换行、制表符**：大多数占位符（如 `%d`, `%f`, `%s`）会自动跳过输入中的空格、换行符和制表符，但 `%c` 不会。
- **输入不匹配格式**：`scanf` 会停止读取并返回 `0`，剩下的未匹配输入保留在缓冲区中。
- **多余输入**：如果输入比预期多，`scanf` 会处理与格式匹配的部分，多余的输入保留在缓冲区供后续处理。
- **Backspace**：`Backspace` 不会影响 `scanf`，它仅影响终端中的输入缓冲，删除的字符不会被 `scanf` 读取。

掌握这些规律后，你可以根据不同的输入场景合理设计程序的输入处理逻辑。