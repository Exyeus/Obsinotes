```c
# include <stdio.h>
int main()
{
    int budget = 0;
    scanf("%d", &budget);
    int x, y, z;
    int found = 0;
    for (x = 2; x < budget - 14; x+=2)
    {
        for (y = 1; y < budget - 1 - 4; y += 1)
        {
            for (z = 8; z < budget - 8 ; z+=10)
            {
                if ((x != y && x != z && y != z)&&
                ((y < x && x < z)||(z < x && x < y))&&
                ((y < 10) && x > 9||(y > 9))&&
                (2*x + 6*y + z > 0.9*(float)budget)&&
                (2*x + 6*y + z < budget + 1))
                {
                    found = 1;
                    printf("%d %d %d\n",x, y, z);
                }
            }
        }
    }
    if (!found) printf("no answer");
    return 0;
}
```
前面写不好的原因
- 不在于没有使用`float`,因为编译器会自动转成float来比较
- 在于对于z有一段`z < budget - 2*x - 6*y`,问题就出现在这里.
## GPT的说法
好的，让我们用具体的数值来分析为什么原代码中 `z < budget - 2*x - 6*y` 的动态范围会导致无法输出正确的结果。

### 假设数据

- 预算 `budget = 52`（参考样例数据）。
- 根据题目规则：
    - $x$ 是偶数，$x \geq 2$。
    - $y$ 是任意整数。
    - $z$ 是冲锋枪的费用，从 8 开始，每次增加 10。
    - 解的条件是满足总费用范围：$0.9 \times budget \leq 2x + 6y + z \leq budget$，即 $46.8 \leq 2x + 6y + z \leq 52$。

### 原代码的问题

`z` 的上限是 `budget - 2*x - 6*y`。我们来手动计算几个具体值，看看哪些解会被跳过。

---

#### **Case 1: 当 $x = 10$，$y = 2$**

- 固定 $x = 10$ 和 $y = 2$，计算 $z$ 的范围：
    
    - $2x + 6y = 2 \cdot 10 + 6 \cdot 2 = 32$。
    - 所以 $z \leq budget - 2x - 6y = 52 - 32 = 20$。
    
    **`z` 的取值范围**（从 8 开始，步长为 10）：$z = 8, 18$。
    
    检查解：
    
    - 当 $z = 8$，总费用 $2x + 6y + z = 32 + 8 = 40$，不满足 $46.8 \leq 40 \leq 52$，被跳过。
    - 当 $z = 18$，总费用 $2x + 6y + z = 32 + 18 = 50$，满足要求。
    
    **结论**：`z = 18` 是有效解，但它会被遍历到。
    

---

#### **Case 2: 当 $x = 14$，$y = 1$**

- 固定 $x = 14$ 和 $y = 1$，计算 $z$ 的范围：
    
    - $2x + 6y = 2 \cdot 14 + 6 \cdot 1 = 28 + 6 = 34$。
    - 所以 $z \leq budget - 2x - 6y = 52 - 34 = 18$。
    
    **`z` 的取值范围**：$z = 8, 18$。
    
    检查解：
    
    - 当 $z = 8$，总费用 $2x + 6y + z = 34 + 8 = 42$，不满足 $46.8 \leq 42 \leq 52$，被跳过。
    - 当 $z = 18$，总费用 $2x + 6y + z = 34 + 18 = 52$，满足要求。
    
    **结论**：虽然 $z = 18$ 是有效解，但由于 $z$ 的范围受限，部分 $x$ 和 $y$ 的组合会错失。
    

---

#### **Case 3: 当 $x = 16$，$y = 0$**

- 固定 $x = 16$ 和 $y = 0$，计算 $z$ 的范围：
    
    - $2x + 6y = 2 \cdot 16 + 6 \cdot 0 = 32$。
    - 所以 $z \leq budget - 2x - 6y = 52 - 32 = 20$。
    
    **`z` 的取值范围**：$z = 8, 18$。
    
    检查解：
    
    - 当 $z = 8$，总费用 $2x + 6y + z = 32 + 8 = 40$，不满足 $46.8 \leq 40 \leq 52$，被跳过。
    - 当 $z = 18$，总费用 $2x + 6y + z = 32 + 18 = 50$，满足要求。
    
    **结论**：`z = 18` 是有效解，但如果没有更多 $z$ 值被尝试，可能遗漏部分解。
    

---

#### 归纳问题

1. `z < budget - 2*x - 6*y` 过于动态，限制了 $z$ 的取值范围。
2. 当 $x$ 和 $y$ 的取值接近预算上限时，$z$ 的取值范围会大幅缩小，导致符合条件的解被遗漏。
3. 改为 `z < budget - 8` 后，$z$ 的上限固定，避免因 $x, y$ 的变化导致部分值无法遍历到。

---

### 修改后的效果

改为 `z < budget - 8` 后：

- $z$ 的上限固定为 `budget - 8 = 44`（在 $budget = 52$ 时）。
- **取值范围**：$z = 8, 18, 28, 38$。
- 这样可以覆盖更多的 $z$ 值，即使 $x$ 和 $y$ 靠近预算上限，也不会跳过有效解。

希望通过这些具体数值和实例，你能理解原代码的问题所在！
## 继续分析
- 自然顺序, 必须面向x来作为第一层循环
- 注意数据类型的转换
- 注意求稳, 可以把那些有技巧的优化变得更加朴实, 只要计算量不会过大.