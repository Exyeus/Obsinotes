---
sr-due: 2025-07-10
sr-interval: 92
sr-ease: 270
---

[[数据类型]][[指针理解]][[指针参数]]

#review
### **指针基类型与其大小**

指针的基类型决定了<font color="#31d83b">指针的“步长”</font>，即当指针执行算术操作（如加减运算）时，指针的偏移量是基类型的大小。因此，理解不同基类型的大小是使用指针的核心。

以下是指针基类型的定义：  

**指针基类型**是指针所指向数据的类型。例如，`int *p` 的基类型是 `int`，大小为 `sizeof(int)`。

---

### **20种不同基类型及其指针的步长大小**

| **编号** | **基类型定义**                    | **大小 (Bytes)**             | **说明**                                                                |
| ------ | ---------------------------- | -------------------------- | --------------------------------------------------------------------- |
| 1      | `char`                       | `1`                        | 基本类型，存储单个字符                                                           |
| 2      | `unsigned char`              | `1`                        | 无符号字符类型，与 `char` 大小相同                                                 |
| 3      | `short`                      | `2` 或 `4`                  | 短整型，具体大小取决于平台                                                         |
| 4      | `unsigned short`             | `2` 或 `4`                  | 无符号短整型                                                                |
| 5      | `int`                        | `4`                        | 常见整型，大小通常为 4 字节                                                       |
| 6      | `unsigned int`               | `4`                        | 无符号整型                                                                 |
| 7      | `long`                       | `4` 或 `8`                  | 长整型，具体大小依赖于平台                                                         |
| 8      | `long long`                  | `8`                        | 长长整型，固定 8 字节                                                          |
| 9      | `float`                      | `4`                        | 单精度浮点型                                                                |
| 10     | `double`                     | `8`                        | 双精度浮点型                                                                |
| 11     | `long double`                | `8` 或 `16`                 | 扩展精度浮点型，依赖于具体实现                                                       |
| 12     | `void`                       | `无法访问基类型大小`                | 不存储任何数据，仅表示地址                                                         |
| 13     | `struct {int a, b;}`         | `8`                        | 两个 `int` 成员的简单结构体                                                     |
| 14     | `struct {char c; double d;}` | `16`                       | 包含 `char` 和 `double`，可能存在<span style="background:#9254de">对齐填充</span> |
| 15     | `union {int x; float y;}`    | `4`                        | 共用体，以最大成员的大小为准                                                        |
| 16     | `char (*)[10]`               | `10`                       | 指向 10 个 `char` 组成的数组                                                  |
| 17     | `int (*)[5][5]`              | `100` $4\times 5 \times 5$ | 指向 5×5 的 `int` 数组                                                     |
| 18     | `int (*)(int, int)`          | `函数指针，步长无法定义`              | 指向返回 `int` 的函数                                                        |
| 19     | `int *`                      | `4/8（指针本身大小）`              | 指向 `int` 的指针                                                          |
| 20     | `double **`                  | `4/8`                      | 指向 `double *` 的指针                                                     |

---

### **分析和补充**

1. **指针的存储大小**
   - 无论指针基类型的大小如何，所有指针在同一平台上的存储大小是相同的。例如：
     - 在 32 位系统中，所有指针大小为 `4` 字节。
     - 在 64 位系统中，所有指针大小为 `8` 字节。

2. **基类型的大小**
   - 指针的基类型大小会影响指针运算。假设 `p` 是 `int *` 指针：
     - `p + 1` 实际偏移了 `sizeof(int)` 字节。

3. **复杂情况**
   - 数组指针（如 `char (*)[10]`）或函数指针（如 `int (*)(int, int)`）的基类型涉及到更复杂的内存布局。
   - 多级指针（如 `double **`）步长取决于基类型指针的大小，而不是具体数据的大小。

4. **特例：`void *`**
   - `void *` 是一种通用指针类型，无法直接访问基类型数据，因为 `void` 没有固定大小。它必须被强制转换为具体类型后才能使用。

---

如果需要更多类型或层次的组合分析，可以继续补充！

---
### **额外20种涉及多维指针、字符指针、回调函数指针的基类型情况**

以下列举更多复杂的指针基类型组合，涵盖多维指针、字符指针、函数指针和数组指针等特殊情况。

---

| **编号** | **基类型定义**                  | **大小 (Bytes)**         | **说明**                                    |
|----------|---------------------------------|---------------------------|--------------------------------------------|
| 1        | `char **`                      | `4/8`                     | 指向 `char *` 的指针                        |
| 2        | `char ***`                     | `4/8`                     | 指向 `char **` 的指针                       |
| 3        | `const char *`                 | `1（基类型步长）`         | 指向只读字符数据                            |
| 4        | `volatile char *`              | `1（基类型步长）`         | 指向易变字符数据                            |
| 5        | `const char **`                | `4/8`                     | 指向 `const char *` 的指针                  |
| 6        | `void (*)()`                   | 无法访问基类型大小        | 指向无参数、无返回值的函数                  |
| 7        | `int (*)(int)`                 | 无法访问基类型大小        | 指向带一个整型参数的函数                    |
| 8        | `void (*)(char *)`             | 无法访问基类型大小        | 指向带 `char *` 参数的函数                  |
| 9        | `int (*)(void *, size_t)`      | 无法访问基类型大小        | 指向带两个参数的回调函数                    |
| 10       | `double (**)(int, int)`        | 无法访问基类型大小        | 指向返回 `double` 的函数指针的指针          |
| 11       | `char (*)[20]`                 | `20`                      | 指向 20 个字符的数组                        |
| 12       | `int (*)[5][5]`                | `100`                     | 指向 5×5 的二维整型数组                     |
| 13       | `float (*)[10]`                | `40`                      | 指向 10 个浮点数的数组                      |
| 14       | `double (***[3])(int)`         | 无法访问基类型大小        | 指向函数指针数组的指针                      |
| 15       | `struct {int x;} **`           | `4/8`                     | 指向结构体指针的指针                        |
| 16       | `union {int x; char c;} ***`   | `4/8`                     | 指向共用体指针的指针                        |
| 17       | `char *(*)[10]`                | `4/8`                     | 指向 `char *` 数组的指针                    |
| 18       | `int *(**)[5]`                 | `4/8`                     | 指向指针数组的指针                          |
| 19       | `void (***)(int, char *)`      | 无法访问基类型大小        | 指向回调函数指针的指针                      |
| 20       | `int (*(*)(void))(char *)`     | 无法访问基类型大小        | 返回函数指针的函数指针                      |

---

### **分析与本质**
这些复杂指针的意义可以从以下几个角度分析：

1. **字符指针与多级字符指针**
   - `char *` 是指向单个字符数组的起始地址。
   - `char **` 是指向字符串指针（即字符数组指针）的指针。例如，一个字符串数组可以使用 `char **` 存储。
   - 多级指针（如 `char ***`）进一步提升了间接访问的层次，常用于动态分配多维数组或处理复杂的内存结构。

2. **回调函数指针**
   - 函数指针（如 `int (*)(int)`）是指向函数的指针，用于动态调用函数。
   - 回调函数通常被用作参数传递，例如 `qsort` 的自定义比较器函数。
   - 多级函数指针（如 `void (***)(int)`）允许将函数指针动态存储在数组或其他复杂结构中。

3. **数组指针**
   - 如 `int (*)[5]` 是一个指向数组的指针，步长为数组的大小。
   - 指针与数组的结合让我们可以高效操作多维数组，而无需明确地嵌套循环或直接访问偏移量。

4. **函数指针数组**
   - 像 `double (***[3])(int)` 是函数指针的数组，可以用来动态切换不同的回调逻辑。
   - 这是事件驱动模型和插件化开发的基础之一。

5. **平台依赖的指针大小**
   - 无论基类型大小如何，指针本身的大小是固定的，与平台位宽一致（32 位或 64 位）。
   - 但是指针的步长（即偏移量）完全取决于基类型的大小。

---

如果需要更具体的某一类指针（如多维数组指针或复杂函数指针）的深入讲解，可以继续展开！