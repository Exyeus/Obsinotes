![[Pasted image 20241121113933.png]]
这段代码的核心是利用指针参数来实现二维数组中某一行数据的查找和输出。下面分步骤详细解析每个部分，尤其是指针参数的表达、传递和输出。

---

### **代码结构分析**

#### **1. 数据定义部分**
```c
float score[][4] = {
    {60, 70, 80, 90},
    {56, 89, 67, 88},
    {34, 78, 90, 66},
};
```
- **含义**：定义了一个二维数组 `score`，包含 3 行 4 列的学生成绩。
- **存储方式**：在内存中，`score` 按行存储（行优先）。`score[0][0]` 到 `score[0][3]` 是第一行，接着存储第二行、第三行。

---

#### **2. 函数声明**
```c
float *search(float (*pointer)[4], int n);
```
- **参数解释**：
  - `pointer` 是一个指向**4 个浮点数一维数组**的指针（也就是二维数组的每一行）。
  - `n` 是一个整数，表示需要查找的行号。

- **返回值**：
  - 函数返回一个指向浮点数的指针，用于指向查找到的 `score` 数组中第 `n` 行的起始地址（即 `&score[n][0]`）。

---

#### **3. 函数实现**
```c
float *search(float (*pointer)[4], int n) {
    float *pt;
    pt = *(pointer + n);  // 获取 pointer 指向的第 n 行地址
    return pt;            // 返回该行地址
}
```
- `pointer` 是传入的指向二维数组的指针。
- `pointer + n`：指针移动到二维数组的第 `n` 行（因为 `pointer` 的单位是一个 **4 个浮点数的数组**）。
- `*(pointer + n)`：解引用，获取第 `n` 行的首地址。
- 最终将这个首地址保存在 `pt` 中，并返回给调用者。

---

#### **4. 主函数部分**
**主逻辑代码分析：**
```c
p = search(score, k);  // 调用 search 函数，获取第 k 行首地址
for (i = 0; i < 4; i++) {
    printf("%5.2f\t", *(p + i));  // 通过指针输出第 k 行数据
}
```
- **`search` 函数调用**：
  - 传入参数 `score`（二维数组首地址）和 `k`（要查找的行号）。
  - 函数返回 `score[k][0]` 的地址，赋值给指针 `p`。
- **通过指针访问数据**：
  - 使用 `*(p + i)` 遍历输出第 `k` 行的 4 个元素。
  - `p` 是行首地址，`p + i` 是第 `i` 个元素的地址，`*(p + i)` 是对应的值。

---

### **指针参数的核心细节**

#### **1. 指针的传递**
- `score` 作为二维数组，传递给函数时会退化为指向第一行的指针，即 `score` 是类型为 `float (*)[4]` 的指针。
- 在 `search` 函数中，`pointer` 接收了 `score` 的地址，指向整个二维数组。

#### **2. 指针的偏移**
- `(pointer + n)`：由于 `pointer` 是指向包含 4 个浮点数的数组的指针，指针加 1 会跳过 4 个浮点数。
  - **实际效果**：`pointer + n` 指向了第 `n` 行的首地址。
- `*(pointer + n)`：解引用操作，得到第 `n` 行<font color="#ffff00">首地址的值</font>。

#### **3. 输出的实现**
- `p` 保存了 `score[k]` 的地址。
- `*(p + i)` 遍历访问 `score[k][i]`：
  - `p + i` 是 `score[k][i]` 的地址。
  - `*(p + i)` 是 `score[k][i]` 的值。

---

### **代码运行的流程**

1. 用户输入要查找的学生序号 `k`。
   - 如果输入 `k = 1`，表示查找 `score[1]`，即 `{56, 89, 67, 88}`。

2. 调用 `search(score, k)`：
   - 将二维数组 `score` 的地址传递给 `pointer`。
   - 通过 `pointer + k` 定位到 `score[1]` 的首地址并返回。

3. 主函数中，利用 `p` 遍历输出第 1 行的成绩：
   - 输出结果依次为 `56.00`、`89.00`、`67.00`、`88.00`。

---

### **关键图解**

#### **指针传递和偏移的可视化：**
- 假设 `score` 在内存中的起始地址为 `0x1000`，每个浮点数占用 4 字节：
  - `score[0]` 的地址：`0x1000`
  - `score[1]` 的地址：`0x1010`
  - `score[2]` 的地址：`0x1020`

当 `pointer = score` 时：
- `pointer + 1`：跳过 4 个浮点数，指向 `score[1]`，地址为 `0x1010`。
	注意，是16进制，10就是16，也就是4\*4

---

### **总结**

- **指针参数的作用**：通过传递二维数组的首地址，结合指针偏移快速定位到目标行。
- **指针的偏移和解引用**：利用 `(pointer + n)` 和 `*(pointer + n)` 实现了行定位。
- **输出数据**：通过指针偏移和解引用 `*(p + i)` <font color="#ffff00">遍历</font><font color="#ffff00">目标行的数据</font>。

这段代码的设计利用了指针的灵活性，实现了高效的二维数组行访问和数据输出。