[[YOJ_TREE]]
这个问题可以通过动态规划来解决。我们需要从树的底层往上计算每一层的最大值，然后最后到达顶层时，得到的数就是从底到顶的最大桃子数。

### 动态规划思路：

1. 从树的底部开始处理，逐层计算每个树枝所能获取的最大桃子数。
2. 对于每一层，当前树枝的最大桃子数由两种可能的选择决定：从左上方的树枝或从右上方的树枝。
3. 将这些信息逐步往上推，直到顶层。

### 步骤：

1. 创建一个二维数组来存储树上每一层的桃子数。
2. 从倒数第二层开始，计算每个树枝能达到的最大桃子数，并更新到该树枝上。
3. 最后，根节点（顶层）会保存从底到顶的最大桃子数。

### 代码实现：

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    scanf("%d", &n);  // 读取树的层数
    
    // 动态分配二维数组，保存树上每层的桃子数
    int **array = (int **)malloc((n + 1) * sizeof(int *));
    for (int i = 0; i <= n; i++) {
        array[i] = (int *)malloc((i + 1) * sizeof(int));
    }

    // 读取树上的桃子数
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            scanf("%d", &array[i][j]);
        }
    }

    // 从底部往上计算最大桃子数
    for (int i = n - 1; i >= 1; i--) {  // 从倒数第二层开始
        for (int j = 0; j < i; j++) {
            // 更新当前树枝的最大桃子数
            if (array[i + 1][j] > array[i + 1][j + 1]) {
                array[i][j] += array[i + 1][j];
            } else {
                array[i][j] += array[i + 1][j + 1];
            }
        }
    }

    // 输出顶层树枝的最大桃子数
    printf("%d\n", array[1][0]);

    // 释放动态分配的内存
    for (int i = 0; i <= n; i++) {
        free(array[i]);
    }
    free(array);

    return 0;
}
```

### 解释：

1. **二维数组的定义和初始化**：`array[i][j]` 用于存储第 `i` 层第 `j` 个树枝的桃子数。
2. **输入处理**：从输入中读取每层的桃子数并存储到 `array` 中。
3. **动态规划计算**：从底层到顶层，逐层更新每个树枝的最大可摘桃子数。
4. **输出结果**：最终输出顶层（第一层）树枝的最大桃子数。

### 复杂度分析：

- 时间复杂度：每一层需要遍历一次，最多需要遍历 `n` 层，因此时间复杂度是 O(n^2)。
- 空间复杂度：需要一个二维数组来存储每一层的桃子数，空间复杂度是 O(n^2)。

### 示例：

输入：

```
3
1
2 3
4 6 5
```

输出：

```
10
```

输入：

```
5
45
76 32
45 99 22
33 44 55 66
24 75 32 64 75
```

输出：

```
339
```

通过这种方法，小猴子能够爬到顶层并摘到最多的桃子。