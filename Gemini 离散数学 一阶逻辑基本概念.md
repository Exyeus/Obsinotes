---
sr-due: 2025-04-11
sr-interval: 3
sr-ease: 250
---

#review 

> $\exists$ 经常与 $\land$ 共用
> 区分 $F(x) \land G(x)$ 与 $F(x)\to G(x)$ 的区别
> 后者条件更弱，有可能因为 $F(x)$ 不成立，而使得十分荒谬的 $G(x)$ 成真！
> 一阶逻辑，深入个体与量词！注意常项与变项，前者常常可以用于表述一个特定的人
> $\forall x(\mathrm{Man}(x)\to \mathrm{Mortal}(x))$
> $\exists x(\mathrm{Man}(x) \land \mathrm{Iswise}(x)$
> 一些类比：强条件 难以成立 $p\land q\gg p\to q$ 。因此，是人就会死不强，因为不是人可能就不会死，就不能用$\land$，有人是哲学家就比较强，是人且是哲学家

好的，同学！我们现在要从命题逻辑迈向一个更强大、更富有表达力的逻辑体系——一阶逻辑 (First-Order Logic, FOL)，有时也称为谓词逻辑 (Predicate Logic)。命题逻辑处理的是简单的陈述句及其真假组合，而一阶逻辑能够深入到句子内部，分析其中的对象 (objects)、性质 (properties) 和关系 (relations)，并引入了量词 (quantifiers) 的概念，使我们能够谈论“所有”或“存在某些”。

---

### 1. 引入与动机 (Hook & Motivation)

我们在命题逻辑中可以分析像“苏格拉底是人”这样的简单命题（比如用 `p` 表示），也可以分析“如果下雨，街道就湿” (`r → w`) 这样的复合命题。

但是，命题逻辑无法表达和分析下面这些陈述的内部结构和它们之间的联系：

1.  "苏格拉底是人。"
2.  "柏拉图是人。"
3.  "所有人都会死。"
4.  因此，"苏格拉底会死。"
5.  因此，"柏拉图会死。"

在命题逻辑中，我们只能把 1、2、4、5 看作独立的原子命题（比如 `p`, `q`, `r`, `s`），把 3 也看作一个原子命题（比如 `t`）。这样一来，我们完全丢失了它们之间的内在联系：它们都涉及“人”、“会死”这些概念，以及“苏格拉底”、“柏拉图”这些个体。我们无法从 `p`, `q`, `t` 形式地推导出 `r` 或 `s`。

一阶逻辑的威力在于：

*   它能表达关于个体 (individuals) 或 对象 (objects) 的陈述。
*   它能表达个体的性质 (properties) （例如，“是人”、“是红色的”）。
*   它能表达个体之间的关系 (relations) （例如，“大于”、“是...的朋友”）。
*   它能使用量词 (quantifiers) 来进行概括，表达“对所有个体都成立”（全称量词 ∀）或“至少存在一个个体成立”（存在量词 ∃）。

这使得一阶逻辑能够更精确地刻画数学、计算机科学、哲学以及日常语言中的许多论证和陈述。

---

### 2. 一阶逻辑基本概念详解

一阶逻辑的语言由以下几类符号构成：

a) 个体域 (Domain of Discourse / Universe): U
   *   这是我们讨论的所有对象的集合。它可以是所有自然数 `ℕ = {0, 1, 2, ...}`，所有学生 `{Alice, Bob, Charlie}`，所有实数 `ℝ`，或者任何我们感兴趣的对象集合。
   *   重要性: 一阶逻辑公式的真假是相对于某个<span style="background:#b1ffff">具体的个体域和对符号的解释而言的。离开个体域谈论公式真假没有意义</span>。

b) 常量符号 (Constant Symbols): a, b, c, ...
   *   用来命名个体域 U 中的特定对象。
   *   例子:
      *   如果 U 是自然数，`0`, `1` 可以是常量符号，分别指代数字 0 和 1。
      *   如果 U 是学生，`alice`, `bob` 可以是常量符号，分别指代学生 Alice 和 Bob。
      *   如果 U 是{苏格拉底, 柏拉图}，`socrates`, `plato` 可以是常量符号。

c) 变量符号 (Variable Symbols): x, y, z, ...
   *   用来代表个体域 U 中的任意一个或某些对象，但不指定是哪一个。<span style="background:#b1ffff">它们像是代数中的变量</span>。
   *   变量的主要作用是与量词配合使用。

d) 谓词符号 (Predicate Symbols): P, Q, R, ...
   *   用来表示个体的性质或个体之间的关系。每个谓词符号都有一个固定的元数 (arity)，表示它需要多少个个体作为参数。
   *   一元谓词 (Arity 1): 表示性质。
      *   `Man(x)`: "x 是人"
      *   `Red(x)`: "x 是红色的"
      *   `Prime(x)`: "x 是素数" (如果 U 是自然数)
   *   二元谓词 (Arity 2): 表示两个个体之间的关系。
      *   `Likes(x, y)`: "x 喜欢 y"
      *   `Greater(x, y)`: "x 大于 y" (如果 U 是实数)
      *   `Parent(x, y)`: "x 是 y 的父母"
   *   n 元谓词 (Arity n): 表示 n 个个体之间的关系。
      *   `Between(x, y, z)`: "y 在 x 和 z 之间"

e) 函数符号 (Function Symbols): f, g, h, ...
   *   用来表示从个体域中的一个或多个对象映射到另一个对象的操作。每个函数符号也有一个固定的元数。
   *   一元函数 (Arity 1):
      *   `father(x)`: "x 的父亲" (注意：返回的是一个对象，而不是真假值)
      *   `successor(x)`: "x 的后继" (如在自然数域中，`successor(x)` 通常指 `x+1`)
   *   二元函数 (Arity 2):
      *   `plus(x, y)`: "x 和 y 的和"
      *   `distance(x, y)`: "x 和 y 之间的距离"
   *   零元函数 (Arity 0): 没有参数的函数实际上就是常量。因此，有时常量被视为零元函数符号。
   *   重要区别: 谓词代表关系/性质（结果是真/假），函数代表操作/映射（结果是一个对象）。

f) 逻辑联结词 (Logical Connectives): ¬, ∧, ∨, →, ↔
   *   与命题逻辑中的含义完全相同，用来连接更小的公式构成更复杂的公式。

g) 量词 (Quantifiers):
   *   全称量词 (Universal Quantifier): ∀ ("对于所有/每一个")
      *   `∀x P(x)`: "对于个体域 U 中的所有个体 x，性质 P(x) 都成立。"
   *   存在量词 (Existential Quantifier): ∃ ("存在/至少有一个")
      *   `∃x P(x)`: "在个体域 U 中至少存在一个个体 x，使得性质 P(x) 成立。"

h) 括号与逗号 (Parentheses, Commas): ( ) ,
   *   用于分组和分隔参数，确保公式的结构清晰无歧义。

项 (Term):

在一阶逻辑中，“项”是指代个体域中对象的表达式。它是通过以下方式递归定义的：

1.  常量符号是一个项。(`a`, `0`, `socrates`)
2.  变量符号是一个项。(`x`, `y`)
3.  如果 `f` 是一个 n 元函数符号，`t₁, t₂, ..., tₙ` 是项，那么 `f(t₁, t₂, ..., tₙ)` 也是一个项。
    *   例子: `successor(x)`, `plus(1, y)`, `father(father(alice))`

原子公式 (Atomic Formula):

这是最简单的、不能再分解的公式，它断言一个性质或关系。形式如下：

*   `P(t₁, t₂, ..., tₙ)`，其中 `P` 是一个 n 元谓词符号，`t₁, ..., tₙ` 是项。
    *   例子: `Man(socrates)`, `Prime(successor(0))`, `Likes(x, alice)`, `Greater(plus(x, y), z)`

公式 (Well-Formed Formula - WFF):

一阶逻辑的合式公式 (WFF) 是通过以下规则递归定义的：

1.  原子公式是公式。
2.  如果 `φ` 是公式，那么 `(¬φ)` 也是公式。
3.  如果 `φ` 和 `ψ` 是公式，那么 `(φ ∧ ψ)`, `(φ ∨ ψ)`, `(φ → ψ)`, `(φ ↔ ψ)` 也是公式。
4.  如果 `φ` 是公式，`x` 是变量，那么 `(∀x φ)` 和 `(∃x φ)` 也是公式。（`φ` 称为量词的作用域 Scope）

*   括号的使用: 严格来说，每次应用规则 2, 3, 4 都需要加括号，以避免歧义。但在实践中，根据优先级和结合性，一些括号可以省略。通常量词的优先级最高，然后是 `¬`, `∧`, `∨`, `→`, `↔`。

---

### 3. 命题符号化 (Symbolization)

这是将自然语言句子翻译成一阶逻辑公式的过程。关键在于：

1.  确定个体域 (U): 我们在谈论什么对象？（人？数字？所有物体？）
2.  定义符号: 为句子中出现的常量、谓词、函数选择合适的符号，并明确它们的含义和元数。
3.  构建公式: 使用项、原子公式、逻辑联结词和量词来表达句子的逻辑结构。

示例：

*   个体域 U: 所有在地球上的人。
*   常量: `socrates` (指苏格拉底), `plato` (指柏拉图)
*   谓词: `Man(x)` (x 是人), `Mortal(x)` (x 会死), `Teacher(x, y)` (x 是 y 的老师)

句子翻译:

1.  "苏格拉底是人。"
    *   `Man(socrates)` (原子公式)
2.  "柏拉图是苏格拉底的老师。"
    *   `Teacher(plato, socrates)` (原子公式)
3.  "所有人都会死。"
    *   这里需要全称量词。对于 U 中的每一个个体 `x`，如果 `x` 是人，那么 `x` 会死。
    *   `∀x (Man(x) → Mortal(x))`
    *   注意: 这里不能写成 `∀x (Man(x) ∧ Mortal(x))`，这表示“所有东西既是人又会死”，这太强了，如果个体域里有石头，这个公式就假了。`∀` 通常与 `→` 配合使用。
4.  "有些人是哲学家。"
    *   这里需要存在量词。至少存在一个个体 `x`，使得 `x` 是人并且 `x` 是哲学家。
    *   假设谓词 `Philosopher(x)`: "x 是哲学家"。
    *   `∃x (Man(x) ∧ Philosopher(x))`
    *   注意: 这里不能写成 `∃x (Man(x) → Philosopher(x))`，这表示“存在某个东西，如果它是人，那么它是哲学家”。<span style="background:#b1ffff">这个陈述太弱了，如果个体域里存在一个不是人的东西（比如一块石头）</span>，那么 `Man(stone)` 为假，蕴含式 `Man(stone) → Philosopher(stone)` 就为真<span style="background:#b1ffff">，整个存在量词公式就为真了，但这并没有告诉我们是否存在哲学家</span>。

>`∃` 通常与 `∧` 配合使用。

1.  "没有不会死的人。"
    *   即 "不存在这样的 x，使得 x 是人并且 x 不会死。"
    *   `¬∃x (Man(x) ∧ ¬Mortal(x))`
    *   这等价于 "对于所有 x，如果 x 是人，则 x 会死。" (`∀x (Man(x) → Mortal(x))`) (量词转换律)
$$\forall x \neg(Man(x) \land \neg Mortal(x)) \Leftrightarrow \forall x(\neg Man(x)\lor Mortal(x))\Leftrightarrow \forall x Man(x)\to Mortal(x)$$
2.  "每个人的老师都是人。"
    *   需要函数 `teacher_of(y)`: "y 的老师" (假设每个人只有一个老师，简化模型)
    *   "对于所有的人 `y`，`y` 的老师也是人。"
    *   `∀y (Man(y) → Man(teacher_of(y)))`

---

### 4. 一阶逻辑公式及其解释 (Formulas and Interpretations)

一个一阶逻辑公式本身只是一个符号串，没有固定的真值。它的真假取决于我们如何解释 (Interpret) 这些符号。

解释 (Interpretation) I:

一个解释 `I` 包含以下部分：

1.  指定个体域 (Universe): U (必须非空)
2.  为每个常量符号 `c` 指定 U 中的一个元素 `cᴵ ∈ U`。
3.  为每个 n 元函数符号 `f` 指定 U 上的一个具体函数 `fᴵ: Uⁿ → U`。
4.  为每个 n 元谓词符号 `P` 指定 U 上的一个具体关系 `Pᴵ ⊆ Uⁿ`。
    *   `Pᴵ` 是一个包含所有使 `P` 为真的 n 元组 `(u₁, ..., uₙ)` 的集合。例如，`Manᴵ` 就是 U 中所有人的集合；`Greaterᴵ` 就是所有满足 `u₁ > u₂` 的数对 `(u₁, u₂)` 的集合。

变量赋值 (Variable Assignment) σ:

由于公式中可能包含自由变量 (Free Variables)（未被量词绑定的变量），我们需要一个变量赋值 `σ` 来将这些自由变量映射到个体域 U 中的具体对象。`σ(x)` 表示变量 `x` 在赋值 `σ` 下被赋予的对象。

公式的真值 (Truth Value of a Formula):

一个公式 `φ` 在解释 `I` 和变量赋值 `σ` 下的真值，记作 `I, σ |= φ` (读作 "I, σ 满足 φ" 或 "φ 在 I, σ 下为真")，是递归定义的：

1.  原子公式 `P(t₁, ..., tₙ)`:
    *   首先计算每个项 `tᵢ` 在 `I` 和 `σ` 下的值 `tᵢ<sup>I,σ</sup> ∈ U`。(常量的值由 `I` 决定，变量的值由 `σ` 决定，函数项 `f(...)` 的值通过应用 `fᴵ` 计算得到)。
    *   `I, σ |= P(t₁, ..., tₙ)` 当且仅当由各项的值组成的元组 `(t₁<sup>I,σ</sup>, ..., tₙ<sup>I,σ</sup>)` 属于解释 `I` 为谓词 `P` 指定的关系 `Pᴵ`。

2.  逻辑联结词:
    *   `I, σ |= ¬φ` 当且仅当 `I, σ |= φ` 不成立。
    *   `I, σ |= φ ∧ ψ` 当且仅当 `I, σ |= φ` 并且 `I, σ |= ψ`。
    *   `I, σ |= φ ∨ ψ` 当且仅当 `I, σ |= φ` 或 `I, σ |= ψ` (或两者都成立)。
    *   `I, σ |= φ → ψ` 当且仅当 `I, σ |= φ` 不成立，或者 `I, σ |= ψ` 成立。
    *   `I, σ |= φ ↔ ψ` 当且仅当 `φ` 和 `ψ` 在 `I, σ` 下具有相同的真值。

3.  量词:
    *   `I, σ |= ∀x φ` 当且仅当对于所有个体 `u ∈ U`，公式 `φ` 在解释 `I` 和修改后的赋值 `σ[x/u]` 下为真。（`σ[x/u]` 表示一个与 `σ` 几乎相同，但将变量 `x` 映射到对象 `u` 的赋值）。
    *   `I, σ |= ∃x φ` 当且仅当至少存在一个个体 `u ∈ U`，使得公式 `φ` 在解释 `I` 和修改后的赋值 `σ[x/u]` 下为真。

约束变量与自由变量 (Bound and Free Variables):

*   在公式 `∀x φ` 或 `∃x φ` 中，量词 `∀x` 或 `∃x` 后面的 `x` 称为约束变量 (Bound Variable)。量词的作用域是 `φ`。
*   一个变量如果不是约束变量，或者它出现在量词的作用域之外，它就是自由变量 (Free Variable)。
*   例子: 在 `∀x (P(x) ∧ Q(y))` 中，`x` 是约束变量，`y` 是自由变量。
*   闭公式 (Closed Formula / Sentence): 不含自由变量的公式。只有闭公式才能在给定解释 `I` 下具有确定的真值（其真值不依赖于变量赋值 `σ`）。我们通常关心的都是闭公式。

模型 (Model):

如果一个闭公式 `φ` 在某个解释 `I` 下为真 (`I |= φ`)，那么我们称解释 `I` 是公式 `φ` 的一个模型 (Model)。

---

### 5. 知识点总结与要点提炼 (Summary & Key Takeaways)

*   一阶逻辑 (FOL): 扩展了命题逻辑，能分析对象、性质、关系和量化。
*   核心构件:
    *   个体域 (U): 讨论对象的集合。
    *   常量 (a, b): 指代特定对象。
    *   变量 (x, y): 代表任意对象，与量词配合。
    *   谓词 (P, Q): 表示性质或关系 (结果是真/假)。
    *   函数 (f, g): 表示对象间的操作/映射 (结果是一个对象)。
    *   项 (Term): 指代对象的表达式 (常量、变量、函数应用)。
    *   原子公式: 谓词应用于项 (`P(t₁, ...)`).
    *   逻辑联结词 (¬, ∧, ∨, →, ↔): 连接公式。
    *   量词 (∀, ∃): "所有" 和 "存在"。
*   公式 (WFF): 按规则构造的符号串。
*   命题符号化: 将自然语言翻译为 FOL 公式的过程。注意 `∀` 常与 `→` 连用，`∃` 常与 `∧` 连用。
*   解释 (Interpretation I): 为符号赋予具体含义（指定 U、常量映射、函数实现、谓词关系）。
*   变量赋值 (σ): 为自由变量指定对象。
*   公式真值 (`I, σ |= φ`): 公式在解释和赋值下是否为真，递归定义。
*   约束/自由变量: 变量是否被量词绑定。
*   闭公式/句子: 没有自由变量的公式，其真值仅依赖于解释 `I`。
*   模型: 使闭公式为真的解释 `I`。

---

### 6. 学科思想与延伸思考 (Underlying Philosophy & Further Thinking)

*   表达力 vs. 复杂性: 一阶逻辑比命题逻辑表达力强得多，能够形式化更多的数学和日常推理。但相应的，其理论（如证明、可满足性）也比命题逻辑复杂得多。例如，判断一个一阶逻辑公式是否永真（在所有解释下都为真）是不可判定 (Undecidable) 的，不像命题逻辑（虽然困难 co-NP-c，但至少可判定）。
*   模型论 (Model Theory): 研究形式语言的公式与其数学结构（模型/解释）之间关系的领域。这是现代逻辑学的一个重要分支。
*   证明论 (Proof Theory): 研究形式证明系统（如一阶逻辑的自然推理、公理系统、相继式演算）的性质。
*   高阶逻辑 (Higher-Order Logic): 一阶逻辑量化的对象是个体。高阶逻辑允许量化谓词和函数本身（例如，“存在一个性质 P 使得...”），表达力更强，但也更复杂。
*   在计算机科学中的应用: 数据库理论（关系代数与一阶逻辑密切相关）、人工智能（知识表示）、形式化验证（描述系统性质）、编程语言理论等。

掌握一阶逻辑的基本概念是深入学习许多计算机科学和数学领域的基础。它提供了一种精确的语言来描述和推理我们感兴趣的世界。如果你对某个概念或符号化的例子有疑问，随时可以提出来！