类的**静态成员**与**一般（非静态）成员**在作用域、生命周期、存储方式等方面有显著的不同。下面将逐一分析这些不同点，并详细解释它们之间的区别。

### 1. **作用域（Scope）**

- **静态成员**：静态成员的<font color="#ffff00">作用域是整个类，不依赖于任何对象实例。静态成员是与类关联的，而不是与某个特定对象关联。因此，你可以通过类名来访问静态成员，而无需创建类的实例。</font>
```cpp
class Person
{
	static void hello()
	{
		printf..
	}
}
int main(){
	Person::hell0;
}
```

- 静态成员变量和静态成员函数的作用域是在类的定义内，<font color="#ffff00">而它们的访问是通过类名而非实例化对象来进行的</font>。
    - 访问静态成员时，不需要实例化对象，可以直接通过 `Class::staticMember` 的方式访问。
- **非静态成员**：非静态成员的作用域是与对象实例相关的。它们的生命周期与对象实例相关，必须通过对象实例来访问。
    
    - 访问非静态成员时，必须通过类的实例（对象）来调用，语法形式为 `object.member` 或 `object.method()`。

### 2. **生命周期（Lifetime）**

- **静态成员**：静态成员在整个程序运行期间都存在。它们的生命周期从程序开始到程序结束。无论你创建了多少个类的实例，静态成员只有一份，它是类共享的。
    
    - 静态成员变量在类的第一个实例化对象创建时被初始化，并且在整个程序运行过程中都存在。
    - 静态成员函数与静态成员变量类似，它们是类的一个组成部分，而不是某个对象的组成部分，因此它们在类的生命周期内始终存在。
- **非静态成员**：非静态成员的生命周期是由对象实例的生命周期决定的。当对象创建时，非静态成员被初始化，并且当对象销毁时，非静态成员也会被销毁。
    
    - 每个对象都有自己的非静态成员，它们随对象的创建和销毁而创建和销毁。

### 3. **存储方式（Storage）**

- **静态成员**：<font color="#ffff00">静态成员变量是全局共享的，存储方式为全局变量或静态变量。它们只占用一份内存空间，不依赖于类的实例化对象。静态成员函数也只在类级别存在。</font>

>不像对象里面的东西, 每创造一个, 就有一份.
 
 - 静态成员变量在内存中的位置是固定的，<span style="background:#9254de">它们通常存储在数据段或静态存储区中，内存分配在程序启动时，程序结束时释放</span>。[[static]]   [[存储类别]]
- **非静态成员**：每个对象都有自己的非静态成员，每个对象实例都会为其成员分配单独的内存空间。因此，不同的对象具有不同的非静态成员数据。
    
    - 非静态成员通常存储在堆栈上（在栈上分配内存）或者类的对象实例中。

### 4. **初始化方式**

- **静态成员**：静态成员变量的初始化只能在类外进行。即使你在类内声明了静态成员变量，也必须在类外进行定义和初始化。
    
    - 静态成员函数也可以在类外定义，但可以在类内声明。
- **非静态成员**：非静态成员变量可以在<font color="#ffff00">类内初始化（C++11 及之后版本支持类内初始化）。如果没有在类内初始化，通常在类的构造函数中进行初始化</font>。
    

### 5. **内存分配**

- **静态成员**：静态成员变量在程序启动时分配内存，并且与任何对象实例无关。它们在内存中只分配一次，即使有多个对象，也只有一份静态成员变量。
    
    - 静态成员变量通常在程序启动时由系统分配并初始化，直到程序结束才会释放。
- **非静态成员**：每个对象实例都会为它的非静态成员分配独立的内存。因此，不同对象的非静态成员变量会占用不同的内存空间。
    
    - 非静态成员在类的实例化过程中进行内存分配，并且当对象销毁时，相关内存会被释放。

### 6. **访问权限**

- **静态成员**：静态成员的访问权限与非静态成员相同，可以是 `public`、`protected` 或 `private`。不过，静态成员函数只能访问静态成员，而无法直接访问非静态成员。
    
    - 你可以通过 `Class::staticMember` 访问静态成员，也可以在类的成员函数中使用 `this` 指针来访问静态成员。
- **非静态成员**：非静态成员只能通过类的对象来访问，通常通过 `object.member` 形式来访问。非静态成员函数可以访问类中的所有成员（包括静态成员和非静态成员）。
    

### 7. **`static` 修饰符的作用**

- `static` 修饰符的作用是限制成员的作用域，使其在整个类的范围内有效。静态成员属于类而不是对象实例，可以共享类的所有实例。

### 8. **示例代码：静态与非静态成员的区别**

```cpp
#include <iostream>

class MyClass {
public:
    static int staticVar;   // 静态成员变量
    int nonStaticVar;       // 非静态成员变量

    MyClass(int val) {
        nonStaticVar = val; // 非静态成员在构造函数中初始化
    }

    static void staticFunction() {
        std::cout << "Static Function, Static Var: " << staticVar << std::endl;
    }

    void nonStaticFunction() {
        std::cout << "Non-Static Function, Non-Static Var: " << nonStaticVar << std::endl;
    }
};

// 静态成员变量的定义与初始化
int MyClass::staticVar = 0;

int main() {
    // 静态成员
    MyClass::staticVar = 100;
    MyClass::staticFunction();

    // 非静态成员
    MyClass obj(42);  // 创建对象
    obj.nonStaticFunction();
    
    return 0;
}
```

#### 解析：

- `staticVar` 是静态成员变量，属于类而不是对象，可以通过 `ClassName::staticVar` 直接访问。
- `nonStaticVar` 是非静态成员变量，属于对象实例，每个对象都有自己的 `nonStaticVar`。

在这个例子中，静态成员 `staticVar` 和静态成员函数 `staticFunction` 是与类关联的，而非静态成员 `nonStaticVar` 和 `nonStaticFunction` 必须通过类的对象来访问。

### 总结

|特性|静态成员 (Static)|非静态成员 (Non-static)|
|---|---|---|
|**作用域**|与类相关，不依赖对象实例，类名访问|与对象实例相关，必须通过对象访问|
|**生命周期**|与程序的生命周期相同（从程序启动到结束）|与对象的生命周期相同，创建时初始化，销毁时释放|
|**内存分配**|只有一份内存，所有对象共享|每个对象有自己的内存|
|**初始化**|必须在类外定义并初始化|可以在类内初始化，或者在构造函数中初始化|
|**访问权限**|可以通过类名访问，不能直接访问非静态成员|通过对象实例访问，可以访问静态和非静态成员|

静态成员是类级别的，而非静态成员是对象级别的，这使得静态成员在全局范围内共享，而非静态成员则属于各个实例。